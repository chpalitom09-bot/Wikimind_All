<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WikiMind - Sequence d'Initialisation</title>
    
    <!-- Libraries CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        #ui-layer {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 20;
            opacity: 0; /* Animé par JS */
        }

        .skip-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.6);
            padding: 10px 20px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .skip-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border-color: white;
        }

        /* Overlay de transition de fin */
        #site-reveal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            z-index: 30;
            opacity: 0;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    
    <div id="ui-layer">
        <button class="skip-btn" onclick="skipIntro()">Skip Intro</button>
    </div>

    <div id="site-reveal">
        <!-- Placeholder pour le contenu du site -->
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            duration: 6, // Secondes
            earthRadius: 5,
            textureUrl: 'https://unpkg.com/three-globe/example/img/earth-dark.jpg',
            colors: {
                bg: 0x000000,
                atmosphere: 0x4444ff,
                wMetallic: 0xffffff
            }
        };

        // --- GLOBALS ---
        let scene, camera, renderer, clock;
        let earthMesh, atmosphereMesh, wGroup, textMesh;
        let audioCtx;
        let animationFrameId;
        let isSkipped = false;

        // --- AUDIO ENGINE (Web Audio API - Procedural) ---
        const AudioEngine = {
            init: () => {
                try {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    audioCtx = new AudioContext();
                } catch(e) {
                    console.warn("Web Audio API not supported");
                }
            },
            
            // Son 1: Passage rapide (Doppler Swoosh)
            playSwoosh: () => {
                if (!audioCtx) return;
                const t = audioCtx.currentTime;
                
                // Noise buffer creation
                const bufferSize = audioCtx.sampleRate * 2;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = audioCtx.createBufferSource();
                noise.buffer = buffer;

                const filter = audioCtx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.Q.value = 1;

                const gain = audioCtx.createGain();
                
                // Panner for stereo movement
                const panner = audioCtx.createStereoPanner();

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(panner);
                panner.connect(audioCtx.destination);

                // Automation
                filter.frequency.setValueAtTime(100, t);
                filter.frequency.exponentialRampToValueAtTime(3000, t + 0.5); // Peak at flyby
                filter.frequency.exponentialRampToValueAtTime(100, t + 1.5);

                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(1, t + 0.5);
                gain.gain.linearRampToValueAtTime(0, t + 1.5);

                panner.pan.setValueAtTime(-0.8, t);
                panner.pan.linearRampToValueAtTime(0.8, t + 1.5);

                noise.start(t);
                noise.stop(t + 2);
            },

            // Son 2: Accélération Turbine
            playTurbine: () => {
                if (!audioCtx) return;
                const t = audioCtx.currentTime;

                const osc = audioCtx.createOscillator();
                osc.type = 'sawtooth';
                
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.Q.value = 2;

                const gain = audioCtx.createGain();

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);

                // Pitch rising
                osc.frequency.setValueAtTime(50, t);
                osc.frequency.exponentialRampToValueAtTime(400, t + 1.5);

                // Filter opening
                filter.frequency.setValueAtTime(100, t);
                filter.frequency.linearRampToValueAtTime(800, t + 1.5);

                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.3, t + 1.0);
                gain.gain.linearRampToValueAtTime(0, t + 2.0);

                osc.start(t);
                osc.stop(t + 2.0);
            },

            // Son 3: Impact Final (Deep Boom + Digital Chime)
            playLock: () => {
                if (!audioCtx) return;
                const t = audioCtx.currentTime;

                // Sub Bass Boom
                const oscBass = audioCtx.createOscillator();
                oscBass.type = 'sine';
                const gainBass = audioCtx.createGain();
                
                oscBass.connect(gainBass);
                gainBass.connect(audioCtx.destination);

                oscBass.frequency.setValueAtTime(150, t);
                oscBass.frequency.exponentialRampToValueAtTime(40, t + 0.5);
                
                gainBass.gain.setValueAtTime(1, t);
                gainBass.gain.exponentialRampToValueAtTime(0.01, t + 1.5);

                oscBass.start(t);
                oscBass.stop(t + 1.5);

                // High Tech Ping
                const oscPing = audioCtx.createOscillator();
                oscPing.type = 'sine';
                const gainPing = audioCtx.createGain();
                
                oscPing.connect(gainPing);
                gainPing.connect(audioCtx.destination);

                oscPing.frequency.setValueAtTime(2000, t);
                gainPing.gain.setValueAtTime(0.1, t);
                gainPing.gain.exponentialRampToValueAtTime(0.001, t + 0.5);

                oscPing.start(t);
                oscPing.stop(t + 0.5);
            }
        };

        // --- 3D SCENE SETUP ---
        function initScene() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 25);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 2);
            sunLight.position.set(10, 5, 10);
            scene.add(sunLight);

            // Rim lights for "W" metal reflections
            const rimLight1 = new THREE.PointLight(0x4488ff, 5, 50);
            rimLight1.position.set(-10, 5, 5);
            scene.add(rimLight1);
            
            const rimLight2 = new THREE.PointLight(0xffffff, 2, 50);
            rimLight2.position.set(10, -5, 10);
            scene.add(rimLight2);
        }

        // --- EARTH SHADER & MESH ---
        function createEarth(texture) {
            // GLSL Custom Shader for B&W High Contrast Earth
            const earthMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: texture },
                    lightDirection: { value: new THREE.Vector3(1, 0.5, 1).normalize() }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    
                    void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        vViewPosition = -mvPosition.xyz;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;

                    void main() {
                        vec4 texColor = texture2D(tDiffuse, vUv);
                        
                        // Convert to Grayscale
                        float gray = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
                        
                        // High Contrast (Thresholding oceans to black)
                        float contrast = smoothstep(0.05, 0.4, gray);
                        
                        // Atmosphere Rim Effect (Fresnel)
                        vec3 viewDir = normalize(vViewPosition);
                        float fresnel = dot(vNormal, viewDir);
                        float rim = 1.0 - fresnel;
                        rim = pow(rim, 3.0);

                        // Mix Earth with Rim
                        vec3 finalColor = vec3(contrast) + (vec3(rim) * 0.3);

                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `
            });

            earthMesh = new THREE.Mesh(new THREE.SphereGeometry(CONFIG.earthRadius, 64, 64), earthMaterial);
            scene.add(earthMesh);

            // Atmosphere Glow Mesh
            const atmoGeo = new THREE.SphereGeometry(CONFIG.earthRadius * 1.05, 64, 64);
            const atmoMat = new THREE.ShaderMaterial({
                transparent: true,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.6 - dot(vNormal, vec3(0, 0, 1.0)), 4.0);
                        gl_FragColor = vec4(1.0, 1.0, 1.0, intensity * 0.8);
                    }
                `
            });
            atmosphereMesh = new THREE.Mesh(atmoGeo, atmoMat);
            scene.add(atmosphereMesh);
        }

        // --- W OBJECT GENERATION ---
        function createWLogo() {
            const shape = new THREE.Shape();
            
            // Dessin vectoriel du W (centré)
            const w = 4;
            const h = 3;
            
            shape.moveTo(-w/2, h/2);
            shape.lineTo(-w/2 + 0.8, h/2);
            shape.lineTo(-w/4, -h/2 + 1); // Bas gauche
            shape.lineTo(0, 0); // Pointe centrale haute
            shape.lineTo(w/4, -h/2 + 1); // Bas droit
            shape.lineTo(w/2 - 0.8, h/2);
            shape.lineTo(w/2, h/2);
            shape.lineTo(w/4 + 0.2, -h/2);
            shape.lineTo(0, -0.5); // Pointe centrale basse
            shape.lineTo(-w/4 - 0.2, -h/2);
            shape.lineTo(-w/2, h/2);

            const extrudeSettings = {
                depth: 0.5,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.1,
                bevelSegments: 4
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.center(); // Centre la géométrie pour la rotation

            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 1.0,
                roughness: 0.15,
                envMapIntensity: 1.0
            });

            const mesh = new THREE.Mesh(geometry, material);
            wGroup = new THREE.Group();
            wGroup.add(mesh);
            wGroup.position.set(0, 0, 20); // Position de départ (derrière cam ou loin)
            scene.add(wGroup);
        }

        // --- TEXT GENERATION (Canvas Texture) ---
        function createText() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1024;
            canvas.height = 256;

            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = 'bold 120px "Segoe UI", Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ffffff';
            ctx.shadowColor = "rgba(255, 255, 255, 0.8)";
            ctx.shadowBlur = 20;
            ctx.fillText('WIKIMIND', canvas.width / 2, canvas.height / 2 + 40);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                opacity: 0,
                depthWrite: false
            });

            const geometry = new THREE.PlaneGeometry(8, 2);
            textMesh = new THREE.Mesh(geometry, material);
            textMesh.position.set(0, -4.5, 8); // Devant la terre
            textMesh.scale.set(0.8, 0.8, 0.8);
            scene.add(textMesh);
        }

        // --- ANIMATION SEQUENCE (GSAP) ---
        function startAnimation() {
            const tl = gsap.timeline({
                onComplete: enterSite
            });

            // Variables de contrôle
            const state = {
                earthRotSpeed: 0.002,
                wProgress: 0
            };

            // Reveal UI Skip
            gsap.to('#ui-layer', { opacity: 1, duration: 1, delay: 0.5 });

            // T=0.5s -> T=2.5s : W Fly-by
            // Le W vient de derrière (z=20), passe la caméra, va vers la terre
            tl.to(wGroup.position, {
                z: 8,
                duration: 2.0,
                ease: "power2.inOut",
                onStart: () => AudioEngine.playSwoosh()
            }, 0.5);

            // Rotation dynamique du W pendant le vol
            tl.to(wGroup.rotation, {
                z: Math.PI * 2, // 360 spin
                x: Math.PI * 0.1,
                duration: 2.0,
                ease: "power1.inOut"
            }, 0.5);

            // T=2.5s -> T=4.0s : Orbite et Accélération
            // W orbite autour de la terre (simulé par rotation group ou x/z)
            tl.to(wGroup.position, {
                x: 0,
                y: 0,
                z: 6,
                duration: 1.5,
                ease: "power2.out"
            }, 2.5);

            // Accélération Terre
            tl.to(state, {
                earthRotSpeed: 0.15, // Très rapide
                duration: 1.5,
                ease: "expo.in",
                onStart: () => AudioEngine.playTurbine(),
                onUpdate: () => {
                    earthMesh.rotation.y += state.earthRotSpeed;
                    // Léger tremblement caméra
                    camera.position.x = (Math.random() - 0.5) * 0.1;
                    camera.position.y = (Math.random() - 0.5) * 0.1;
                }
            }, 2.5);

            // Recul Caméra
            tl.to(camera.position, {
                z: 18,
                duration: 1.5,
                ease: "power2.inOut"
            }, 2.5);

            // T=4.0s : LOCK FINAL
            // Stop accélération terre
            tl.to(state, {
                earthRotSpeed: 0.002,
                duration: 0.5,
                ease: "power2.out",
                onUpdate: () => {
                    earthMesh.rotation.y += state.earthRotSpeed;
                    camera.position.x = 0; // Reset shake
                    camera.position.y = 0;
                }
            }, 4.0);

            // Disparition du W (fusion)
            tl.to(wGroup.scale, {
                x: 0, y: 0, z: 0,
                duration: 0.3,
                ease: "back.in(1.7)"
            }, 4.0);

            // Apparition Texte + Pulse
            tl.to(textMesh.material, { opacity: 1, duration: 0.1 }, 4.3);
            tl.fromTo(textMesh.scale, 
                { x: 0.5, y: 0.5 }, 
                { 
                    x: 1.2, y: 1.2, 
                    duration: 0.4, 
                    ease: "elastic.out(1, 0.3)",
                    onStart: () => AudioEngine.playLock()
                }, 
                4.3
            );

            // Stabilisation pour la lecture (T=5s to 6s)
            tl.to(textMesh.scale, { x: 1, y: 1, duration: 1 }, 4.7);

            // Loop de rendu pour mettre à jour les rotations continues
            gsap.ticker.add(() => {
                if(!isSkipped) {
                    // Rotation de base de la terre si pas en accélération
                    if(state.earthRotSpeed < 0.05) {
                        earthMesh.rotation.y += state.earthRotSpeed;
                    }
                    atmosphereMesh.rotation.y = earthMesh.rotation.y;
                    
                    // Lent mouvement de l'atmosphère
                    atmosphereMesh.scale.setScalar(1.05 + Math.sin(Date.now() * 0.001) * 0.01);
                }
            });
        }

        // --- MAIN INITIALIZATION ---
        function init() {
            initScene();
            createWLogo();
            createText();
            AudioEngine.init();

            // Setup Texture Loading
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(CONFIG.textureUrl, (texture) => {
                createEarth(texture);
                
                // Démarrer l'animation une fois chargé
                // Petit hack pour débloquer l'audio si l'utilisateur a cliqué quelque part, 
                // sinon l'audio sera silencieux mais visuel OK.
                document.body.addEventListener('click', () => {
                    if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
                }, { once: true });

                startAnimation();
                animate();

            }, undefined, (err) => {
                console.error("Erreur chargement texture, fallback couleur");
                // Fallback si pas internet
                const fallbackTex = new THREE.DataTexture(new Uint8Array([50, 50, 50]), 1, 1, THREE.RGBFormat);
                createEarth(fallbackTex);
                startAnimation();
                animate();
            });

            // Resize Handler
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function animate() {
            if (isSkipped) return;
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // --- EXIT FUNCTIONS ---
        function skipIntro() {
            if(isSkipped) return;
            isSkipped = true;
            gsap.globalTimeline.clear(); // Kill animations
            enterSite();
        }

        function enterSite() {
            isSkipped = true;
            
            // Animation de sortie (Fade out Canvas -> White)
            const reveal = document.getElementById('site-reveal');
            const canvas = document.getElementById('canvas-container');
            const ui = document.getElementById('ui-layer');

            ui.style.display = 'none';

            // Animation CSS/GSAP de transition
            gsap.to(canvas, {
                opacity: 0,
                duration: 1,
                ease: "power2.inOut"
            });

            reveal.style.opacity = 1;
            reveal.style.pointerEvents = 'auto'; // Active les clics

            // Redirection après le fondu
            setTimeout(() => {
                // REDIRECTION VERS L'ACCUEIL DU PROJET
                // Remplace 'index.html' par le vrai fichier d'accueil si différent
                window.location.href = "index.html"; 
            }, 1000);
        }

        // --- LAUNCH ---
        init();

    </script>
</body>
</html>
