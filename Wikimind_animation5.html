--- START OF FILE text/html ---

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WikiMind - Initialisation</title>
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            overflow: hidden;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Overlay Text Container */
        #text-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Le Titre Final */
        #main-title {
            margin-top: 32vh; /* Position sous la terre (ajusté dynamiquement par JS si besoin) */
            font-size: clamp(2rem, 8vw, 6rem); /* Responsive font size */
            font-weight: 900;
            color: #ffffff;
            opacity: 0;
            letter-spacing: -5px; /* Départ serré */
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            white-space: nowrap;
        }

        /* Overlay blanc de transition */
        #flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
        }

        /* Loading Spinner discret */
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            z-index: 0;
        }
    </style>

    <!-- GSAP for Animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>

    <div id="loader">Chargement Neural...</div>
    <div id="canvas-container"></div>
    
    <div id="text-overlay">
        <h1 id="main-title">WIKIMIND</h1>
    </div>

    <div id="flash-overlay"></div>

    <!-- Script Module pour Three.js moderne -->
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.128.0/build/three.module.js';
        import { FontLoader } from 'https://unpkg.com/three@0.128.0/examples/jsm/loaders/FontLoader.js';
        import { TextGeometry } from 'https://unpkg.com/three@0.128.0/examples/jsm/geometries/TextGeometry.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            earthRadius: 4,
            colors: {
                bg: 0x000000,
                wColor: 0xffffff,
                lightTrail: 0x00ffff // Cyan pour le sillage du W
            },
            urls: {
                // Texture standard de la terre (sera transformée en N&B par shader)
                earth: 'https://unpkg.com/three-globe/example/img/earth-dark.jpg', 
                // Font JSON standard
                font: 'https://unpkg.com/three@0.128.0/examples/fonts/helvetiker_bold.typeface.json'
            }
        };

        // --- GLOBALS ---
        let scene, camera, renderer;
        let earthMesh, atmosphereMesh, starsMesh;
        let wMesh, wGroup, wLight;
        let audioCtx;
        
        // --- AUDIO ENGINE (Silent start compliant) ---
        const AudioEngine = {
            ctx: null,
            init: () => {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    AudioEngine.ctx = new AudioContext();
                    // Resume context on first user interaction
                    const resumeAudio = () => {
                        if (AudioEngine.ctx.state === 'suspended') AudioEngine.ctx.resume();
                        window.removeEventListener('click', resumeAudio);
                        window.removeEventListener('touchstart', resumeAudio);
                    };
                    window.addEventListener('click', resumeAudio);
                    window.addEventListener('touchstart', resumeAudio);
                }
            },
            playSwoosh: () => {
                if (!AudioEngine.ctx || AudioEngine.ctx.state === 'suspended') return;
                const t = AudioEngine.ctx.currentTime;
                const osc = AudioEngine.ctx.createOscillator();
                const gain = AudioEngine.ctx.createGain();
                const filter = AudioEngine.ctx.createBiquadFilter();

                // Noise simulation (Pink noise logic simplified with oscillator modulation)
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(50, t);
                osc.frequency.exponentialRampToValueAtTime(800, t + 1);
                osc.frequency.exponentialRampToValueAtTime(50, t + 2);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, t);
                filter.frequency.linearRampToValueAtTime(5000, t + 1); // Open filter on pass

                gain.gain.setValueAtTime(0, t);
                gain.gain.linearRampToValueAtTime(0.3, t + 1);
                gain.gain.linearRampToValueAtTime(0, t + 2);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(AudioEngine.ctx.destination);
                osc.start(t);
                osc.stop(t + 2.5);
            },
            playImpact: () => {
                if (!AudioEngine.ctx || AudioEngine.ctx.state === 'suspended') return;
                const t = AudioEngine.ctx.currentTime;
                
                // Low Boom
                const osc = AudioEngine.ctx.createOscillator();
                const gain = AudioEngine.ctx.createGain();
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 1);
                gain.gain.setValueAtTime(1, t);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 1);
                
                osc.connect(gain);
                gain.connect(AudioEngine.ctx.destination);
                osc.start(t);
                osc.stop(t + 1);
            }
        };

        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            // Camera (FOV 45)
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition(); // Initial position based on screen ratio

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Perf optimization
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(50, 20, 30);
            sunLight.castShadow = true;
            scene.add(sunLight);

            // Back/Rim Light for the Earth edge
            const rimLight = new THREE.SpotLight(0x4455ff, 5);
            rimLight.position.set(-10, 10, -10);
            rimLight.lookAt(0, 0, 0);
            scene.add(rimLight);

            // Audio Init
            AudioEngine.init();

            // Load Assets
            const manager = new THREE.LoadingManager();
            manager.onLoad = () => {
                document.getElementById('loader').style.display = 'none';
                startSequence();
            };

            const textureLoader = new THREE.TextureLoader(manager);
            const fontLoader = new FontLoader(manager);

            // 1. Load Earth
            textureLoader.load(CONFIG.urls.earth, (tex) => {
                createEarth(tex);
                createStars();
            });

            // 2. Load Font & Create W
            fontLoader.load(CONFIG.urls.font, (font) => {
                createWLogo(font);
            });

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            
            // Loop
            animate();
        }

        // --- CREATION FUNCTIONS ---

        function createEarth(texture) {
            // Custom Shader Material for High Contrast B&W Look
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: texture },
                    sunDirection: { value: new THREE.Vector3(1, 0.5, 1).normalize() }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        vViewPosition = -mvPosition.xyz;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;

                    void main() {
                        vec4 texColor = texture2D(tDiffuse, vUv);
                        
                        // Grayscale conversion
                        float gray = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));
                        
                        // Thresholding: Oceans (dark) -> Black, Continents (light) -> White
                        // Smoothstep for slightly soft edges (antialiasing effect)
                        float contrast = smoothstep(0.15, 0.25, gray);
                        
                        // Atmosphere Fresnel (Rim light)
                        vec3 viewDir = normalize(vViewPosition);
                        float fresnel = dot(vNormal, viewDir);
                        float rim = 1.0 - fresnel;
                        rim = pow(rim, 4.0);

                        // Combine: Earth Surface + Rim
                        vec3 finalColor = vec3(contrast) + (vec3(rim) * 0.4);

                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `
            });

            earthMesh = new THREE.Mesh(new THREE.SphereGeometry(CONFIG.earthRadius, 64, 64), material);
            scene.add(earthMesh);

            // Atmosphere Glow (Outer shell)
            const atmoGeo = new THREE.SphereGeometry(CONFIG.earthRadius * 1.1, 64, 64);
            const atmoMat = new THREE.ShaderMaterial({
                transparent: true,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.6 - dot(vNormal, vec3(0, 0, 1.0)), 6.0);
                        gl_FragColor = vec4(0.5, 0.7, 1.0, intensity * 0.5);
                    }
                `
            });
            atmosphereMesh = new THREE.Mesh(atmoGeo, atmoMat);
            scene.add(atmosphereMesh);
        }

        function createStars() {
            const starGeo = new THREE.BufferGeometry();
            const count = 2000;
            const posArray = new Float32Array(count * 3);
            for(let i=0; i<count*3; i++) {
                posArray[i] = (Math.random() - 0.5) * 100;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const starMat = new THREE.PointsMaterial({size: 0.1, color: 0x555555});
            starsMesh = new THREE.Points(starGeo, starMat);
            scene.add(starsMesh);
        }

        function createWLogo(font) {
            const geometry = new TextGeometry('W', {
                font: font,
                size: 2.5,
                height: 0.5, // Thickness
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.1,
                bevelSize: 0.05,
                bevelOffset: 0,
                bevelSegments: 5
            });

            geometry.center(); // Important pour la rotation

            const material = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 1.0,
                roughness: 0.1,
                emissive: 0x222222,
                emissiveIntensity: 0.2
            });

            wMesh = new THREE.Mesh(geometry, material);
            
            // Container Group for animation
            wGroup = new THREE.Group();
            wGroup.add(wMesh);

            // Dynamic Light attached to the W (The "Energy Source")
            wLight = new THREE.PointLight(CONFIG.colors.lightTrail, 2, 20);
            wLight.position.set(0, 0, 0);
            wGroup.add(wLight);

            // Start position: Behind camera, slightly to the left
            wGroup.position.set(-5, 2, 20); 
            wGroup.visible = false; // Hidden until start

            scene.add(wGroup);
        }

        // --- ANIMATION SEQUENCE ---

        function startSequence() {
            wGroup.visible = true;
            
            const tl = gsap.timeline({
                onComplete: () => {
                    setTimeout(redirect, 1500);
                }
            });

            // 0s - 2.5s: Le W passe la caméra et tourne autour de la terre
            // Trajectoire courbe simulée par position et rotation
            
            AudioEngine.playSwoosh();

            // Mouvement du W (Bezier curve style via GSAP)
            tl.to(wGroup.position, {
                x: 0, y: 0, z: 6, // Position finale devant la terre
                duration: 3,
                ease: "power2.inOut",
                onUpdate: () => {
                    // Ajout d'une rotation chaotique qui se stabilise
                    wMesh.rotation.x += 0.05;
                    wMesh.rotation.y += 0.1;
                }
            });

            // Stabilisation de la rotation du W à la fin
            tl.to(wMesh.rotation, {
                x: 0, y: 0, z: 0,
                duration: 1,
                ease: "elastic.out(1, 0.5)"
            }, "-=1.0");

            // Recul Caméra pour cadrer la Terre + le Texte
            tl.to(camera.position, {
                z: isMobile() ? 25 : 18,
                duration: 3,
                ease: "power1.inOut"
            }, 0);

            // Accélération de la Terre au passage du W
            tl.to(earthMesh.rotation, {
                y: Math.PI * 2,
                duration: 3,
                ease: "expo.out"
            }, 0);

            // 4.0s : Impact & Disparition W -> Text Reveal
            tl.to(wGroup.scale, {
                x: 0.01, y: 0.01, z: 0.01,
                duration: 0.3,
                ease: "back.in(2)",
                onComplete: () => {
                    wGroup.visible = false;
                    AudioEngine.playImpact();
                    revealText();
                }
            });

            // Flash blanc
            tl.to('#flash-overlay', {
                opacity: 0.2,
                duration: 0.1,
                yoyo: true,
                repeat: 1
            }, "<"); // Starts with previous anim
        }

        function revealText() {
            const title = document.getElementById('main-title');
            
            // Animation Tracking (espacement lettres) + Fade In
            gsap.to(title, {
                opacity: 1,
                letterSpacing: "10px", // Écartement
                duration: 2.5,
                ease: "power2.out"
            });
        }

        function redirect() {
            // Fondu au blanc total
            gsap.to('#flash-overlay', {
                opacity: 1,
                duration: 1,
                onComplete: () => {
                    window.location.href = "index.html";
                }
            });
        }

        // --- UTILS & HELPERS ---

        function isMobile() {
            return window.innerWidth < 768;
        }

        function updateCameraPosition() {
            const aspect = window.innerWidth / window.innerHeight;
            // Si écran vertical (mobile), on recule la caméra
            if (aspect < 1) {
                camera.position.z = 28;
            } else {
                camera.position.z = 18;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateCameraPosition();
        }

        function animate() {
            requestAnimationFrame(animate);

            // Rotation lente permanente
            if(earthMesh) {
                earthMesh.rotation.y += 0.001;
                atmosphereMesh.rotation.y = earthMesh.rotation.y;
            }
            if(starsMesh) {
                starsMesh.rotation.y -= 0.0005;
            }

            renderer.render(scene, camera);
        }

        // Start init
        init();

    </script>
</body>
</html>