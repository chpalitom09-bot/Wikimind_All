<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WikiMind GTW - Chaos Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .ui-layer { position: absolute; pointer-events: none; width: 100%; height: 100%; top: 0; left: 0; z-index: 10; }
        .hud-panel { background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(5px); pointer-events: auto; }
        
        /* Killfeed */
        #killfeed { position: absolute; top: 20px; right: 20px; text-align: right; display: flex; flex-direction: column; gap: 5px; }
        .kill-msg { background: rgba(200,0,0,0.4); padding: 4px 8px; border-radius: 4px; color: white; font-size: 12px; font-weight: bold; animation: fadeOut 5s forwards; }
        @keyframes fadeOut { 0% { opacity: 1; } 90% { opacity: 1; } 100% { opacity: 0; } }

        /* Crosshair */
        #crosshair { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 20px; height: 20px; pointer-events: none; transition: transform 0.1s; }
        
        /* Inventory Bar */
        .inv-slot { width: 40px; height: 40px; border: 1px solid #555; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; font-size: 10px; color: white; position: relative; }
        .inv-slot.active { border: 2px solid yellow; background: rgba(255,255,0,0.2); transform: scale(1.1); }
        .inv-key { position: absolute; top: 0; left: 2px; font-size: 8px; color: #aaa; }
        
        /* Interaction Prompt */
        #interact-msg { position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%); color: yellow; font-weight: bold; font-size: 14px; text-shadow: 0 2px 4px black; display: none; }
        
        /* Start Overlay */
        #start-screen { position: absolute; z-index: 50; inset: 0; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; flex-direction: column; pointer-events: auto; }
    </style>
</head>
<body>

    <!-- START SCREEN -->
    <div id="start-screen">
        <h1 class="text-6xl font-black text-yellow-500 italic mb-4 tracking-tighter">WIKIMIND <span class="text-white">GTW</span></h1>
        <p class="text-gray-300 mb-8">Cliquez pour capturer la souris et jouer</p>
        <button id="start-btn" class="bg-yellow-500 text-black font-bold px-8 py-3 rounded-full hover:bg-white transition">JOUER</button>
    </div>

    <!-- UI LAYER -->
    <div class="ui-layer flex flex-col justify-between p-6" id="ui-layer" style="display:none;">
        <!-- Top -->
        <div class="flex justify-between items-start">
            <div class="text-white drop-shadow-md">
                <div class="font-black text-2xl italic">GTW ONLINE</div>
                <div class="text-xs text-green-400 font-mono">PING: <span id="ping">24</span>ms | PLAYERS: <span id="player-count">0</span></div>
            </div>
            <div id="killfeed"></div>
        </div>

        <!-- Center Interaction -->
        <div id="interact-msg">[F] Monter dans le v√©hicule</div>
        
        <!-- Crosshair -->
        <div id="crosshair">
            <svg viewBox="0 0 100 100" fill="none" stroke="white" stroke-width="2" style="filter: drop-shadow(0 0 2px black);">
                <circle cx="50" cy="50" r="2" fill="white"/>
                <line x1="40" y1="50" x2="60" y2="50" />
                <line x1="50" y1="40" x2="50" y2="60" />
            </svg>
        </div>

        <!-- Bottom Inventory & Stats -->
        <div class="flex flex-col items-center gap-4 w-full">
            
            <!-- HP & Ammo -->
            <div class="flex gap-4 items-end w-full max-w-3xl px-10 justify-between">
                <div class="w-64">
                    <div class="flex justify-between text-xs font-bold text-white uppercase mb-1">
                        <span>Sant√©</span>
                        <span id="hp-val">100</span>
                    </div>
                    <div class="h-4 bg-gray-800 rounded-full overflow-hidden border border-gray-600">
                        <div id="hp-bar" class="h-full bg-gradient-to-r from-red-600 to-red-400 w-full transition-all"></div>
                    </div>
                </div>
                <div class="text-right">
                    <div class="text-4xl font-black text-yellow-400" id="ammo-display">‚àû</div>
                    <div class="text-xs text-gray-400 uppercase" id="weapon-name">Couteau</div>
                </div>
            </div>

            <!-- Inventory Slots -->
            <div class="flex gap-2 bg-black/50 p-2 rounded-xl backdrop-blur-md" id="inventory-container">
                <!-- G√©n√©r√© par JS -->
            </div>
        </div>
    </div>

    <div id="game-container"></div>

    <!-- MODULES -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
        import { getDatabase, ref, set, onValue, onDisconnect, push, remove, update } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-auth.js";

        // --- FIREBASE CONFIG ---
        const firebaseConfig = {
            apiKey: "AIzaSyCuozxRg0t1MyzaoMwYDdWK6nyE3Btd--o",
            authDomain: "wikimind-gtw.firebaseapp.com",
            databaseURL: "https://wikimind-gtw-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "wikimind-gtw",
            storageBucket: "wikimind-gtw.firebasestorage.app",
            messagingSenderId: "576444288903",
            appId: "1:576444288903:web:e8568ba12fab086c794d22"
        };
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);

        // --- INVENTORY DATA ---
        const INVENTORY = [
            { id: 0, name: 'COUTEAU', icon: 'üî™', type: 'melee', dmg: 25, range: 5, rate: 500 },
            { id: 1, name: 'PISTOLET', icon: 'üî´', type: 'hitscan', dmg: 15, range: 100, rate: 400, ammo: Infinity },
            { id: 2, name: 'POMPE', icon: 'üí•', type: 'shotgun', dmg: 10, count: 6, range: 40, rate: 1000, ammo: 50 },
            { id: 3, name: 'ASSAUT', icon: 'rifle', type: 'hitscan', dmg: 12, range: 200, rate: 100, ammo: 200 },
            { id: 4, name: 'SNIPER', icon: 'üéØ', type: 'hitscan', dmg: 80, range: 500, rate: 1500, ammo: 20 },
            { id: 5, name: 'GRENADE', icon: 'üí£', type: 'projectile', pType: 'frag', dmg: 90, radius: 20, rate: 1000, ammo: 5 },
            { id: 6, name: 'LACRYMO', icon: 'üí®', type: 'projectile', pType: 'smoke', dmg: 1, radius: 30, rate: 1000, ammo: 5 },
            { id: 7, name: 'BAZOOKA', icon: 'üöÄ', type: 'projectile', pType: 'rocket', dmg: 100, radius: 15, rate: 2000, ammo: 5 },
            { id: 8, name: 'AVION BOMB', icon: '‚úàÔ∏è', type: 'plane_bomb', dmg: 150, radius: 40, rate: 500, ammo: Infinity } // Slot sp√©cial
        ];

        // --- GRAPHICS ENGINE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.FogExp2(0x87CEEB, 0.0015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(renderer.domElement);

        // Lights
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(100, 300, 100);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.top = 500;
        dirLight.shadow.camera.bottom = -500;
        dirLight.shadow.camera.left = -500;
        dirLight.shadow.camera.right = 500;
        scene.add(dirLight);

        // Controls
        const controls = new PointerLockControls(camera, document.body);
        
        // --- GAME STATE ---
        let me = { hp: 100, x: 0, y: 0, z: 0, slot: 1, inVehicle: false, vType: null };
        let myId = null;
        const players = {}; 
        const projectiles = []; // Local projectiles array
        const explosions = [];
        
        // Input
        const keys = { w: false, a: false, s: false, d: false, space: false, shift: false };
        let canShoot = true;

        // --- WORLD GENERATION ---
        const TILE_SIZE = 50;
        const MAP_SIZE = 40;
        const cityGroup = new THREE.Group();
        const colliders = [];
        const vehicles = [];

        // Texture G√©n√©rator (Fen√™tres)
        function createBuildingTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#444'; ctx.fillRect(0,0,64,64); // Mur
            ctx.fillStyle = '#111'; ctx.fillRect(0,0,64,4); // Corniche
            // Fenetres
            ctx.fillStyle = Math.random() > 0.5 ? '#6688aa' : '#223344'; // Allum√©e ou √©teinte
            if (Math.random()>0.3) ctx.fillRect(10, 10, 15, 25);
            if (Math.random()>0.3) ctx.fillRect(35, 10, 15, 25);
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        const buildingMat = new THREE.MeshPhongMaterial({ map: createBuildingTexture() });
        const roadMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
        const grassMat = new THREE.MeshPhongMaterial({ color: 0x335533 });

        // Generate City
        for(let x=0; x<MAP_SIZE; x++) {
            for(let z=0; z<MAP_SIZE; z++) {
                const posX = (x - MAP_SIZE/2) * TILE_SIZE;
                const posZ = (z - MAP_SIZE/2) * TILE_SIZE;

                // Simple Grid City
                if (x === 0 || x === MAP_SIZE-1 || z === 0 || z === MAP_SIZE-1 || x%4 === 0 || z%4 === 0) {
                    // ROUTE
                    const road = new THREE.Mesh(new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE), roadMat);
                    road.rotation.x = -Math.PI/2;
                    road.position.set(posX, 0.05, posZ);
                    road.receiveShadow = true;
                    cityGroup.add(road);
                } else {
                    // BATIMENT
                    if (Math.random() > 0.2) {
                        const h = 50 + Math.random() * 200; // Hauteur variable
                        const geo = new THREE.BoxGeometry(TILE_SIZE-4, h, TILE_SIZE-4);
                        // UV Mapping rapide pour r√©p√©ter la texture
                        const uvAttribute = geo.attributes.uv;
                        for ( let i = 0; i < uvAttribute.count; i ++ ) {
                            // Simple scaling
                            uvAttribute.setY( i, uvAttribute.getY( i ) * (h/30) );
                        }
                        
                        const b = new THREE.Mesh(geo, buildingMat);
                        b.position.set(posX, h/2, posZ);
                        b.castShadow = true;
                        b.receiveShadow = true;
                        cityGroup.add(b);
                        colliders.push(new THREE.Box3().setFromObject(b));
                    } else {
                        // PARC
                        const park = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE, 2, TILE_SIZE), grassMat);
                        park.position.set(posX, 1, posZ);
                        cityGroup.add(park);
                    }
                }
            }
        }
        
        // Sol g√©ant
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(5000, 5000), new THREE.MeshBasicMaterial({color:0x1a1a1a}));
        floor.rotation.x = -Math.PI/2;
        cityGroup.add(floor);
        scene.add(cityGroup);

        // --- VEHICLES SPAWN ---
        // On g√©n√®re quelques v√©hicules statiques interactifs
        const vehicleGeo = new THREE.BoxGeometry(20, 10, 35);
        const planeGeo = new THREE.ConeGeometry(10, 40, 8); planeGeo.rotateX(Math.PI/2);
        
        function spawnVehicle(type, x, z) {
            const mesh = new THREE.Group();
            let body;
            if(type === 'car') {
                body = new THREE.Mesh(vehicleGeo, new THREE.MeshStandardMaterial({color: Math.random()*0xffffff}));
                body.position.y = 5;
                const wheels = new THREE.Mesh(new THREE.BoxGeometry(22, 4, 20), new THREE.MeshBasicMaterial({color:0x000000}));
                wheels.position.y = 2;
                mesh.add(wheels);
            } else {
                body = new THREE.Mesh(planeGeo, new THREE.MeshStandardMaterial({color: 0xffaa00}));
                body.position.y = 10;
                // Ailes
                const wings = new THREE.Mesh(new THREE.BoxGeometry(60, 2, 10), new THREE.MeshStandardMaterial({color: 0xffaa00}));
                wings.position.set(0, 10, 0);
                mesh.add(wings);
            }
            mesh.add(body);
            mesh.position.set(x, 0, z);
            mesh.castShadow = true;
            
            scene.add(mesh);
            vehicles.push({ type: type, mesh: mesh, x: x, z: z, id: Math.random().toString(36) });
        }

        // Spawn quelques voitures et un avion
        for(let i=0; i<10; i++) spawnVehicle('car', (Math.random()-0.5)*1000, (Math.random()-0.5)*1000);
        spawnVehicle('plane', 0, 0); // Avion au centre

        // --- PLAYER CONTROLLER ---
        
        const playerMesh = new THREE.Group(); // Visual representation (invisible for self)
        scene.add(playerMesh);

        // Camera Logic
        const yawObject = new THREE.Object3D();
        const pitchObject = new THREE.Object3D();
        pitchObject.add(camera);
        yawObject.add(pitchObject);
        scene.add(yawObject);
        
        // Weapon Model (First person placeholder)
        const weaponHand = new THREE.Mesh(new THREE.BoxGeometry(1,1,4), new THREE.MeshLambertMaterial({color:0x333}));
        weaponHand.position.set(2, -2, -5);
        camera.add(weaponHand);

        // Inventory UI Generation
        const invContainer = document.getElementById('inventory-container');
        INVENTORY.forEach(item => {
            if (item.id === 8) return; // Skip plane bomb in UI
            const el = document.createElement('div');
            el.className = 'inv-slot';
            el.innerHTML = `<span class="inv-key">${item.id+1}</span>${item.icon}`;
            el.id = `slot-${item.id}`;
            invContainer.appendChild(el);
        });

        function updateInventoryUI() {
            document.querySelectorAll('.inv-slot').forEach(el => el.classList.remove('active'));
            const current = INVENTORY[me.slot];
            if(current && current.id < 8) document.getElementById(`slot-${current.id}`).classList.add('active');
            
            document.getElementById('weapon-name').innerText = current ? current.name : '';
            document.getElementById('ammo-display').innerText = current ? (current.ammo === Infinity ? '‚àû' : current.ammo) : 0;
        }

        // --- LOGIC LOOP ---
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);

            if (controls.isLocked) {
                // --- MOVEMENT ---
                if (me.inVehicle) {
                    // VEHICLE CONTROL
                    const speed = me.vType === 'plane' ? 80 : 40;
                    
                    // Avion : Mouse Y = Pitch, A/D = Roll/Yaw approx
                    if (me.vType === 'plane') {
                         yawObject.translateZ(-speed * delta);
                         // Contr√¥le altitude via Pitch cam√©ra
                         // Le vecteur avant de l'objet d√©termine la direction
                    } else {
                        // Voiture : Au sol
                        if (keys.w) yawObject.translateZ(-speed * delta);
                        if (keys.s) yawObject.translateZ(speed * delta);
                        // Pour tourner en voiture, on tourne la cam (PointerLock) donc c'est implicite
                    }
                    
                    // Sortir
                    document.getElementById('interact-msg').style.display = 'block';
                    document.getElementById('interact-msg').innerText = "[F] Sortir";

                } else {
                    // HUMAN MOVEMENT
                    velocity.x -= velocity.x * 10.0 * delta;
                    velocity.z -= velocity.z * 10.0 * delta;
                    velocity.y -= 9.8 * 30.0 * delta; // Gravity

                    direction.z = Number(keys.w) - Number(keys.s);
                    direction.x = Number(keys.d) - Number(keys.a);
                    direction.normalize();

                    if (keys.w || keys.s) velocity.z -= direction.z * 400.0 * delta;
                    if (keys.a || keys.d) velocity.x -= direction.x * 400.0 * delta;

                    // Apply Movement relative to Yaw
                    yawObject.translateX(velocity.x * delta);
                    yawObject.translateZ(velocity.z * delta);
                    yawObject.position.y += velocity.y * delta; // Falling

                    // Floor Collision
                    if (yawObject.position.y < 5) {
                        velocity.y = 0;
                        yawObject.position.y = 5;
                        if (keys.space) velocity.y = 200; // Jump
                    }

                    // Check vehicle interaction
                    let nearVehicle = null;
                    vehicles.forEach(v => {
                         if (yawObject.position.distanceTo(v.mesh.position) < 30) nearVehicle = v;
                    });
                    
                    const uiMsg = document.getElementById('interact-msg');
                    if (nearVehicle) {
                        uiMsg.style.display = 'block';
                        uiMsg.innerText = `[F] Piloter ${nearVehicle.type.toUpperCase()}`;
                    } else {
                        uiMsg.style.display = 'none';
                    }
                }

                // Update Camera
                me.x = yawObject.position.x;
                me.y = yawObject.position.y;
                me.z = yawObject.position.z;

                // Sync Mesh position (so bullets originate correctly)
                playerMesh.position.copy(yawObject.position);
                playerMesh.rotation.copy(yawObject.rotation);
            }

            // --- PROJECTILES ---
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.mesh.position.addScaledVector(p.velocity, delta);
                p.velocity.y -= 9.8 * delta; // Gravity

                // Collision sol
                if (p.mesh.position.y <= 0) {
                    createExplosion(p.mesh.position, p.data.radius, p.data.dmg);
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            }

            // --- EXPLOSIONS VISUALS ---
            for (let i = explosions.length - 1; i >= 0; i--) {
                const ex = explosions[i];
                ex.mesh.scale.multiplyScalar(1.1);
                ex.mesh.material.opacity -= delta * 2;
                if(ex.mesh.material.opacity <= 0) {
                    scene.remove(ex.mesh);
                    explosions.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }
        
        // --- COMBAT SYSTEM ---

        function shoot() {
            if(!canShoot) return;
            const weapon = me.inVehicle && me.vType === 'plane' ? INVENTORY[8] : INVENTORY[me.slot];
            
            if (weapon.ammo <= 0 && weapon.ammo !== Infinity) return;
            
            // Recul / Cadence
            canShoot = false;
            setTimeout(() => canShoot = true, weapon.rate);
            
            if(weapon.ammo !== Infinity) weapon.ammo--;
            updateInventoryUI();

            // Logic
            if (weapon.type === 'hitscan' || weapon.type === 'shotgun') {
                // Raycast
                const raycaster = new THREE.Raycaster();
                // Partir du centre de l'√©cran
                raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                
                // Effet visuel (Tracer)
                // ...
                
                // Check Players
                // Note: Dans une vraie impl√©m, on checke les BoundingBox des meshes joueurs distants
                // Ici on va simplifier en envoyant un event "shoot" au serveur ou en checkant localement les distances
                
                // On checke les intersections avec le d√©cor pour l'impact
                const intersects = raycaster.intersectObjects(cityGroup.children);
                if(intersects.length > 0) {
                    // Impact FX
                    createImpact(intersects[0].point);
                }

                // Check players (simplifi√© distance cone)
                for (let pid in players) {
                    if (pid === myId) continue;
                    const p = players[pid];
                    const pPos = new THREE.Vector3(p.x, p.y, p.z);
                    // Angle check
                    const dirToP = pPos.clone().sub(yawObject.position).normalize();
                    const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir);
                    if (camDir.angleTo(dirToP) < 0.1) { // Vis√©
                         // HIT
                         damagePlayer(pid, weapon.dmg);
                         break; // Hit one
                    }
                }

            } else if (weapon.type === 'projectile' || weapon.type === 'plane_bomb') {
                // Spawn projectile
                const geo = new THREE.SphereGeometry(1, 8, 8);
                const mat = new THREE.MeshBasicMaterial({color: weapon.type === 'plane_bomb' ? 0x000000 : 0x00ff00});
                const mesh = new THREE.Mesh(geo, mat);
                
                const spawnPos = yawObject.position.clone();
                if(weapon.type === 'plane_bomb') spawnPos.y -= 5;
                else spawnPos.add(new THREE.Vector3(0, 0, 0).applyQuaternion(yawObject.quaternion)); // Devant

                mesh.position.copy(spawnPos);
                scene.add(mesh);

                const vel = new THREE.Vector3(0, 0, -1).applyQuaternion(pitchObject.getWorldQuaternion(new THREE.Quaternion()));
                if(weapon.type === 'plane_bomb') vel.set(0, -1, 0); // Tombe tout droit
                
                vel.multiplyScalar(weapon.type === 'rocket' ? 100 : 30); // Vitesse
                if(weapon.type === 'plane_bomb') vel.multiplyScalar(0.5);

                projectiles.push({ mesh: mesh, velocity: vel, data: weapon });
            }
        }

        function createExplosion(pos, radius, dmg) {
            // Visual
            const geo = new THREE.SphereGeometry(radius, 16, 16);
            const mat = new THREE.MeshBasicMaterial({color: 0xffaa00, transparent: true, opacity: 1});
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            scene.add(mesh);
            explosions.push({ mesh: mesh });

            // Damage AOE
            for (let pid in players) {
                if(pid === myId) continue; // Pas de friendly fire sur soi (optionnel)
                const p = players[pid];
                const dist = new THREE.Vector3(p.x, p.y, p.z).distanceTo(pos);
                if (dist < radius) {
                    damagePlayer(pid, dmg * (1 - dist/radius));
                }
            }
        }
        
        function createImpact(pos) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({color:0xffff00}));
            mesh.position.copy(pos);
            scene.add(mesh);
            setTimeout(() => scene.remove(mesh), 500);
        }

        function damagePlayer(targetId, dmg) {
             // On triche un peu : on lit/ecrit direct dans la DB de l'autre
             // Id√©alement : Cloud Function ou validation serveur
             update(ref(db, `players/${targetId}`), {
                 hp_hit: dmg // On envoie un signal "hit" et l'autre client g√®re sa vie, ou on force la vie
             }).catch(()=>{});
        }

        // --- NETWORK & SYNC ---

        signInAnonymously(auth).then((cred) => {
            myId = cred.user.uid;
            
            // Initial State
            me.hp = 100;
            me.x = (Math.random()-0.5) * 200;
            me.z = (Math.random()-0.5) * 200;
            me.y = 5;
            yawObject.position.set(me.x, me.y, me.z);

            const userRef = ref(db, `players/${myId}`);
            onDisconnect(userRef).remove();

            // Listen Loop
            onValue(ref(db, 'players'), (snap) => {
                const data = snap.val() || {};
                document.getElementById('player-count').innerText = Object.keys(data).length;
                
                // Sync Remote Players
                for(let id in data) {
                    if (id === myId) {
                        // Check si on a pris des d√©gats (via le signal hp_hit hack)
                        if (data[id].hp_hit) {
                            me.hp -= data[id].hp_hit;
                            // Reset signal
                            update(ref(db, `players/${myId}`), { hp_hit: null });
                            updateHUD();
                        }
                        continue;
                    }

                    const pData = data[id];
                    if(!players[id]) {
                        // Create mesh
                        const mesh = new THREE.Mesh(new THREE.BoxGeometry(4, 12, 4), new THREE.MeshLambertMaterial({color: pData.color || 0xff0000}));
                        scene.add(mesh);
                        players[id] = { mesh: mesh, data: pData };
                    }
                    
                    // Update Mesh
                    const p = players[id];
                    p.mesh.position.set(pData.x, pData.y + 6, pData.z); // +6 pour centrer boite
                    // p.mesh.rotation.y = pData.rot; // Si on sync la rotation
                    
                    // Si vehicule, changer modele (simplifi√© ici : on change couleur)
                    p.mesh.material.color.setHex(pData.inVehicle ? 0xffff00 : (pData.color || 0xff0000));
                }

                // Remove disconnected
                for(let id in players) {
                    if(!data[id]) {
                        scene.remove(players[id].mesh);
                        delete players[id];
                    }
                }
            });
            
            setInterval(sendLoop, 50);
            animate();

        });

        function sendLoop() {
            if(!myId) return;
            update(ref(db, `players/${myId}`), {
                x: me.x,
                y: me.y,
                z: me.z,
                inVehicle: me.inVehicle,
                hp: me.hp
            });
        }
        
        function updateHUD() {
            document.getElementById('hp-val').innerText = Math.floor(me.hp);
            document.getElementById('hp-bar').style.width = Math.max(0, me.hp) + '%';
            if(me.hp <= 0) {
                // Respawn
                me.hp = 100;
                me.inVehicle = false;
                me.y = 100; // Parachute spawn
                yawObject.position.y = 100;
                me.slot = 1;
                INVENTORY.forEach(i => { if(i.ammo !== Infinity) i.ammo = 5; }); // Reset ammo
                updateInventoryUI();
            }
        }

        // --- INPUTS ---
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyW') keys.w = true;
            if (e.code === 'KeyA') keys.a = true;
            if (e.code === 'KeyS') keys.s = true;
            if (e.code === 'KeyD') keys.d = true;
            if (e.code === 'Space') keys.space = true;
            if (e.code === 'KeyF') handleInteract();
            
            // Inventory 1-9
            const num = parseInt(e.key);
            if (!isNaN(num) && num >= 1 && num <= 9) {
                if (INVENTORY[num-1]) {
                    me.slot = num-1;
                    updateInventoryUI();
                }
            }
        });
        document.addEventListener('keyup', (e) => {
            if (e.code === 'KeyW') keys.w = false;
            if (e.code === 'KeyA') keys.a = false;
            if (e.code === 'KeyS') keys.s = false;
            if (e.code === 'KeyD') keys.d = false;
            if (e.code === 'Space') keys.space = false;
        });
        document.addEventListener('mousedown', () => {
             if (controls.isLocked) shoot();
        });

        function handleInteract() {
            if (me.inVehicle) {
                // Exit
                me.inVehicle = false;
                me.vType = null;
                yawObject.position.x += 10; // D√©caler pour pas √™tre bloqu√© dedans
            } else {
                // Enter ?
                vehicles.forEach(v => {
                    if (yawObject.position.distanceTo(v.mesh.position) < 30) {
                        me.inVehicle = true;
                        me.vType = v.type;
                        // Teleport player visual inside (camera reste attach√©e √† yawObject qui va bouger comme un vehicule)
                        yawObject.position.copy(v.mesh.position);
                        yawObject.position.y += v.type === 'plane' ? 10 : 5;
                    }
                });
            }
        }

        // UI START
        document.getElementById('start-btn').addEventListener('click', () => {
            controls.lock();
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'flex';
            updateInventoryUI();
        });
        
        controls.addEventListener('unlock', () => {
            document.getElementById('start-screen').style.display = 'flex';
            document.getElementById('ui-layer').style.display = 'none';
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
