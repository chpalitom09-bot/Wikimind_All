<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WikiMind GTW 3D - Online</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .ui-layer { position: absolute; pointer-events: none; width: 100%; height: 100%; top: 0; left: 0; z-index: 10; }
        .hud-panel { background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.2); backdrop-filter: blur(4px); pointer-events: auto; }
        
        #killfeed { position: absolute; top: 20px; right: 20px; text-align: right; display: flex; flex-direction: column; gap: 5px; }
        .kill-msg { background: rgba(255,0,0,0.4); padding: 5px 10px; border-radius: 4px; color: white; font-size: 12px; animation: fadeOut 5s forwards; }
        
        @keyframes fadeOut { 0% { opacity: 1; } 90% { opacity: 1; } 100% { opacity: 0; } }
        
        /* Crosshair au centre pour viser */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none; opacity: 0.7;
        }
    </style>
</head>
<body>

    <!-- UI LAYER -->
    <div class="ui-layer flex flex-col justify-between p-6">
        <div class="flex justify-between items-start">
            <div class="hud-panel p-4 rounded-xl text-white">
                <h1 class="text-2xl font-black italic tracking-tighter text-yellow-400">GTW <span class="text-white">3D</span></h1>
                <div class="text-xs text-gray-400 flex items-center gap-2">
                    <span class="w-2 h-2 bg-green-500 rounded-full animate-pulse"></span>
                    <span id="player-count">0</span> Joueurs
                </div>
            </div>
            <div id="killfeed"></div>
        </div>

        <!-- Crosshair SVG -->
        <div id="crosshair">
            <svg viewBox="0 0 100 100" fill="none" stroke="white" stroke-width="8">
                <circle cx="50" cy="50" r="40" />
                <line x1="50" y1="20" x2="50" y2="80" />
                <line x1="20" y1="50" x2="80" y2="50" />
            </svg>
        </div>

        <div class="flex justify-between items-end">
            <div class="hud-panel p-4 rounded-xl text-white w-64">
                <div class="flex justify-between mb-1">
                    <span class="text-xs font-bold uppercase text-gray-400">Santé</span>
                    <span id="hp-text" class="font-bold text-red-500">100%</span>
                </div>
                <div class="w-full bg-gray-800 h-2 rounded-full overflow-hidden mb-4">
                    <div id="hp-bar" class="h-full bg-red-600 w-full transition-all duration-200"></div>
                </div>
                <p class="text-[10px] text-gray-400 mt-2">
                    ⬆/⬇ : Avancer/Reculer<br>
                    ⬅/➡ : Tourner<br>
                    ESPACE : Tirer | F : Voiture
                </p>
            </div>
        </div>
    </div>

    <!-- 3D CONTAINER -->
    <div id="game-container"></div>

    <!-- MODULES -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js";
        import { getDatabase, ref, set, onValue, onDisconnect, push, remove, update, get } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-database.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.8.0/firebase-auth.js";

        // --- FIREBASE CONFIG ---
        const firebaseConfig = {
            apiKey: "AIzaSyCuozxRg0t1MyzaoMwYDdWK6nyE3Btd--o",
            authDomain: "wikimind-gtw.firebaseapp.com",
            databaseURL: "https://wikimind-gtw-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "wikimind-gtw",
            storageBucket: "wikimind-gtw.firebasestorage.app",
            messagingSenderId: "576444288903",
            appId: "1:576444288903:web:e8568ba12fab086c794d22"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);

        // --- 3D ENGINE SETUP ---
        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Ciel bleu
        scene.fog = new THREE.Fog(0x87CEEB, 200, 900);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1500);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // Lumières
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(100, 200, 50);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 500;
        dirLight.shadow.camera.bottom = -500;
        dirLight.shadow.camera.left = -500;
        dirLight.shadow.camera.right = 500;
        scene.add(dirLight);

        // --- GAME CONSTANTS ---
        const TILE_SIZE = 40; // Echelle 3D
        const MAP_WIDTH = 40;
        const MAP_HEIGHT = 40;
        const WORLD_W = MAP_WIDTH * TILE_SIZE;
        const WORLD_H = MAP_HEIGHT * TILE_SIZE;

        // Materiaux
        const matBuilding = new THREE.MeshPhongMaterial({ color: 0x888888 });
        const matRoad = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const matGrass = new THREE.MeshPhongMaterial({ color: 0x4caf50 });
        const matPlayer = new THREE.MeshPhongMaterial({ color: 0xff0000 });
        const matWheel = new THREE.MeshLambertMaterial({ color: 0x111111 });

        // Map Data & Generation
        const MAP_DATA = [];
        const colliders = []; // Pour physique simple
        let seed = 5678;
        function random() { var x = Math.sin(seed++) * 10000; return x - Math.floor(x); }

        const cityGroup = new THREE.Group();
        scene.add(cityGroup);

        // Sol géant
        const groundGeo = new THREE.PlaneGeometry(WORLD_W * 2, WORLD_H * 2);
        const groundMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.set(WORLD_W/2, -0.1, WORLD_H/2);
        scene.add(ground);

        // Génération procédurale
        for(let z=0; z<MAP_HEIGHT; z++) {
            let row = [];
            for(let x=0; x<MAP_WIDTH; x++) {
                let type = 1; // Batiment par defaut
                
                // Routes
                if (x === 0 || x === MAP_WIDTH-1 || z === 0 || z === MAP_HEIGHT-1) type = 1; // Murs exterieurs
                else if (x % 4 === 0 || z % 4 === 0) type = 0; // Route
                else if (random() > 0.7) type = 2; // Parc

                row.push(type);

                const posX = x * TILE_SIZE;
                const posZ = z * TILE_SIZE;

                if (type === 1) {
                    // BATIMENT
                    const h = 50 + random() * 100;
                    const geo = new THREE.BoxGeometry(TILE_SIZE - 2, h, TILE_SIZE - 2);
                    const mesh = new THREE.Mesh(geo, matBuilding);
                    mesh.position.set(posX, h/2, posZ);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    cityGroup.add(mesh);
                    
                    // Collider simple (Box 2D)
                    colliders.push({ x: posX, z: posZ, size: TILE_SIZE });
                } else if (type === 2) {
                    // PARC
                    const geo = new THREE.BoxGeometry(TILE_SIZE, 2, TILE_SIZE);
                    const mesh = new THREE.Mesh(geo, matGrass);
                    mesh.position.set(posX, 1, posZ);
                    mesh.receiveShadow = true;
                    cityGroup.add(mesh);
                    
                    // Arbre simple
                    if(random() > 0.5) {
                        const treeTrunk = new THREE.Mesh(new THREE.CylinderGeometry(2,2,10), new THREE.MeshLambertMaterial({color:0x5D4037}));
                        treeTrunk.position.set(posX, 5, posZ);
                        cityGroup.add(treeTrunk);
                        const treeTop = new THREE.Mesh(new THREE.ConeGeometry(8,20), new THREE.MeshLambertMaterial({color:0x2E7D32}));
                        treeTop.position.set(posX, 15, posZ);
                        cityGroup.add(treeTop);
                    }
                } else {
                    // ROUTE
                    const geo = new THREE.PlaneGeometry(TILE_SIZE, TILE_SIZE);
                    const mesh = new THREE.Mesh(geo, matRoad);
                    mesh.rotation.x = -Math.PI / 2;
                    mesh.position.set(posX, 0.1, posZ);
                    mesh.receiveShadow = true;
                    cityGroup.add(mesh);
                    
                    // Lignes jaunes
                    if(x%2===0 && z%2!==0) {
                         const line = new THREE.Mesh(new THREE.PlaneGeometry(2, 20), new THREE.MeshBasicMaterial({color:0xFFD700}));
                         line.rotation.x = -Math.PI/2;
                         line.position.set(posX, 0.2, posZ);
                         cityGroup.add(line);
                    }
                }
            }
            MAP_DATA.push(row);
        }

        // --- GAME LOGIC ---
        let me = null;
        let myId = null;
        const playersMap = {}; // Map ID -> { mesh, data }
        const bulletsMap = {}; // Map ID -> { mesh, data }
        
        // Input
        const keys = { up: false, down: false, left: false, right: false, space: false, f: false };
        
        window.addEventListener('keydown', (e) => {
            if (e.key === "ArrowUp") keys.up = true;
            if (e.key === "ArrowDown") keys.down = true;
            if (e.key === "ArrowLeft") keys.left = true;
            if (e.key === "ArrowRight") keys.right = true;
            if (e.key === " ") {
                keys.space = true;
                shoot();
            }
            if (e.key.toLowerCase() === "f") {
                 keys.f = true;
                 toggleCar();
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.key === "ArrowUp") keys.up = false;
            if (e.key === "ArrowDown") keys.down = false;
            if (e.key === "ArrowLeft") keys.left = false;
            if (e.key === "ArrowRight") keys.right = false;
            if (e.key === " ") keys.space = false;
            if (e.key.toLowerCase() === "f") keys.f = false;
        });

        // --- PLAYER & ENTITIES 3D CREATION ---

        function createPlayerMesh(color) {
            const group = new THREE.Group();
            
            // Corps Humain
            const mat = new THREE.MeshPhongMaterial({ color: color });
            const body = new THREE.Mesh(new THREE.BoxGeometry(6, 14, 4), mat);
            body.position.y = 7;
            body.castShadow = true;
            group.add(body);

            const head = new THREE.Mesh(new THREE.BoxGeometry(5, 5, 5), new THREE.MeshLambertMaterial({color: 0xffccaa}));
            head.position.y = 16;
            group.add(head);

            // Arme (cube noir)
            const gun = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 8), new THREE.MeshLambertMaterial({color: 0x000000}));
            gun.position.set(4, 10, 4);
            group.add(gun);

            return group;
        }

        function createCarMesh(color) {
            const group = new THREE.Group();
            const mat = new THREE.MeshPhongMaterial({ color: color });
            
            // Chassis
            const body = new THREE.Mesh(new THREE.BoxGeometry(16, 8, 30), mat);
            body.position.y = 6;
            body.castShadow = true;
            group.add(body);
            
            // Toit
            const top = new THREE.Mesh(new THREE.BoxGeometry(14, 6, 15), mat);
            top.position.set(0, 12, -2);
            group.add(top);

            // Roues
            const wheelGeo = new THREE.CylinderGeometry(3, 3, 2);
            wheelGeo.rotateZ(Math.PI/2);
            const w1 = new THREE.Mesh(wheelGeo, matWheel); w1.position.set(8, 3, 10);
            const w2 = new THREE.Mesh(wheelGeo, matWheel); w2.position.set(-8, 3, 10);
            const w3 = new THREE.Mesh(wheelGeo, matWheel); w3.position.set(8, 3, -10);
            const w4 = new THREE.Mesh(wheelGeo, matWheel); w4.position.set(-8, 3, -10);
            group.add(w1, w2, w3, w4);

            return group;
        }

        // --- AUTH & NETWORK ---

        signInAnonymously(auth).then((cred) => {
            myId = cred.user.uid;
            spawnMe();

            // Disconnect Logic
            const userRef = ref(db, `players/${myId}`);
            onDisconnect(userRef).remove();

            // SYNC PLAYERS
            onValue(ref(db, 'players'), (snapshot) => {
                const data = snapshot.val() || {};
                document.getElementById('player-count').innerText = Object.keys(data).length;

                // Update or Create
                for (let id in data) {
                    if (id === myId) continue; // On gère notre propre mesh localement pour la fluidité
                    const pData = data[id];
                    
                    if (!playersMap[id]) {
                        // Nouveau joueur distant
                        const mesh = pData.inCar ? createCarMesh(pData.carColor || 0xff0000) : createPlayerMesh(pData.skinColor || 0xffffff);
                        scene.add(mesh);
                        playersMap[id] = { mesh, data: pData, isCar: pData.inCar };
                    } else {
                        // Mise à jour existant
                        const pEntry = playersMap[id];
                        
                        // Si changement état voiture, recréer mesh
                        if (pEntry.isCar !== pData.inCar) {
                            scene.remove(pEntry.mesh);
                            const newMesh = pData.inCar ? createCarMesh(pData.carColor) : createPlayerMesh(pData.skinColor);
                            scene.add(newMesh);
                            pEntry.mesh = newMesh;
                            pEntry.isCar = pData.inCar;
                        }

                        // Interpolation simple
                        pEntry.mesh.position.lerp(new THREE.Vector3(pData.x, 0, pData.z), 0.2);
                        // Rotation interpolée (plus complexe avec les angles, on fait simple)
                        pEntry.mesh.rotation.y = pData.angle;
                    }
                }

                // Cleanup disconnected
                for (let id in playersMap) {
                    if (!data[id]) {
                        scene.remove(playersMap[id].mesh);
                        delete playersMap[id];
                    }
                }
            });

            // SYNC BULLETS
            onValue(ref(db, 'bullets'), (snapshot) => {
                const data = snapshot.val() || {};
                
                for(let bid in data) {
                    const bData = data[bid];
                    if (!bulletsMap[bid]) {
                        const geo = new THREE.SphereGeometry(1, 4, 4);
                        const mat = new THREE.MeshBasicMaterial({color: 0xffff00});
                        const mesh = new THREE.Mesh(geo, mat);
                        mesh.position.set(bData.x, 8, bData.z);
                        scene.add(mesh);
                        bulletsMap[bid] = { mesh, data: bData };
                    }
                    // Les balles bougent vite, on fait confiance au serveur/créateur pour la suppression
                }
                
                // Cleanup bullets
                for(let bid in bulletsMap) {
                    if(!data[bid]) {
                        scene.remove(bulletsMap[bid].mesh);
                        delete bulletsMap[bid];
                    }
                }
            });

            // Boucle principale
            animate();
            
            // Sync Loop (Envoi pos)
            setInterval(sendUpdate, 50);

        });

        function spawnMe() {
            let sx, sz;
            // Trouver spot sur route
            while(true) {
                let rx = Math.floor(Math.random() * MAP_WIDTH);
                let rz = Math.floor(Math.random() * MAP_HEIGHT);
                if (MAP_DATA[rz] && MAP_DATA[rz][rx] === 0) {
                    sx = rx * TILE_SIZE;
                    sz = rz * TILE_SIZE;
                    break;
                }
            }

            me = {
                id: myId,
                x: sx,
                z: sz,
                angle: 0,
                hp: 100,
                inCar: false,
                skinColor: '#' + new THREE.Color(`hsl(${Math.random()*360}, 100%, 50%)`).getHexString(),
                carColor: null,
                name: "Player"
            };

            // Créer mon mesh local
            if (playersMap[myId]) scene.remove(playersMap[myId].mesh);
            const mesh = createPlayerMesh(me.skinColor);
            scene.add(mesh);
            playersMap[myId] = { mesh, data: me, isCar: false };
            
            updateHUD();
        }

        function checkCollision(x, z) {
            // Limites monde
            if (x < 0 || x > WORLD_W || z < 0 || z > WORLD_H) return true;
            
            // Batiments (Approche grille simple)
            // On convertit pos x,z en index grille
            const gx = Math.floor((x + TILE_SIZE/2) / TILE_SIZE);
            const gz = Math.floor((z + TILE_SIZE/2) / TILE_SIZE);
            
            if (MAP_DATA[gz] && MAP_DATA[gz][gx] === 1) return true;
            
            return false;
        }

        function toggleCar() {
            if (!me) return;
            // Si pas en voiture, on en "invoque" une ou on rentre dedans (simplifié: toggle immédiat)
            // Pour le fun: on dit qu'on peut spawn une voiture si on est sur la route
            const gx = Math.floor((me.x + TILE_SIZE/2) / TILE_SIZE);
            const gz = Math.floor((me.z + TILE_SIZE/2) / TILE_SIZE);
            
            // Changement d'état
            me.inCar = !me.inCar;
            
            if (me.inCar) {
                me.carColor = '#' + new THREE.Color(`hsl(${Math.random()*360}, 100%, 50%)`).getHexString();
                scene.remove(playersMap[myId].mesh);
                const mesh = createCarMesh(me.carColor);
                scene.add(mesh);
                playersMap[myId].mesh = mesh;
                playersMap[myId].isCar = true;
            } else {
                me.carColor = null;
                scene.remove(playersMap[myId].mesh);
                const mesh = createPlayerMesh(me.skinColor);
                scene.add(mesh);
                playersMap[myId].mesh = mesh;
                playersMap[myId].isCar = false;
            }
        }

        function shoot() {
            if (!me || me.hp <= 0) return;
            const bulletId = push(ref(db, 'bullets')).key;
            // Tirer dans la direction du joueur
            const bData = {
                id: bulletId,
                owner: myId,
                x: me.x + Math.sin(me.angle) * 10,
                z: me.z + Math.cos(me.angle) * 10,
                vx: Math.sin(me.angle), // Vecteur direction
                vz: Math.cos(me.angle),
                timestamp: Date.now()
            };
            
            // On l'ajoute localement pour réactivité
            set(ref(db, `bullets/${bulletId}`), bData);
            
            // Auto delete
            setTimeout(() => { remove(ref(db, `bullets/${bulletId}`)); }, 2000);
        }

        function sendUpdate() {
            if(!me) return;
            // On envoie seulement les données essentielles
            update(ref(db, `players/${myId}`), {
                x: me.x,
                z: me.z,
                angle: me.angle,
                inCar: me.inCar,
                skinColor: me.skinColor,
                carColor: me.carColor,
                hp: me.hp
            });
        }

        function updateHUD() {
            if(!me) return;
            const hpBar = document.getElementById('hp-bar');
            const hpText = document.getElementById('hp-text');
            hpBar.style.width = me.hp + '%';
            hpText.innerText = me.hp + '%';
            
            if(me.hp <= 0) {
                // Respawn
                spawnMe();
                // Reset remote HP
                update(ref(db, `players/${myId}`), { hp: 100 });
            }
        }

        function killFeed(msg) {
            const el = document.createElement('div');
            el.className = 'kill-msg';
            el.innerText = msg;
            document.getElementById('killfeed').prepend(el);
            setTimeout(()=>el.remove(), 5000);
        }

        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. Déplacement Joueur Local
            if (me && playersMap[myId]) {
                const speed = me.inCar ? 4 : 1.5;
                const rotSpeed = me.inCar ? 0.04 : 0.08;

                // Rotation
                if (keys.left) me.angle += rotSpeed;
                if (keys.right) me.angle -= rotSpeed;

                // Avancer / Reculer
                let dx = 0, dz = 0;
                if (keys.up) {
                    dx = Math.sin(me.angle) * speed;
                    dz = Math.cos(me.angle) * speed;
                }
                if (keys.down) {
                    dx = -Math.sin(me.angle) * speed;
                    dz = -Math.cos(me.angle) * speed;
                }

                // Collision Check
                if (!checkCollision(me.x + dx, me.z + dz)) {
                    me.x += dx;
                    me.z += dz;
                }

                // Update Mesh
                const pMesh = playersMap[myId].mesh;
                pMesh.position.set(me.x, 0, me.z);
                pMesh.rotation.y = me.angle; // Rotation Y en ThreeJS est l'axe vertical

                // Update Camera (Suivi Third Person)
                // Position idéale caméra : derrière le joueur et en hauteur
                const camDist = me.inCar ? 80 : 50;
                const camHeight = me.inCar ? 40 : 30;
                
                // Calcul position derrière
                const cx = me.x - Math.sin(me.angle) * camDist;
                const cz = me.z - Math.cos(me.angle) * camDist;

                // Lerp camera pour fluidité
                camera.position.x += (cx - camera.position.x) * 0.1;
                camera.position.z += (cz - camera.position.z) * 0.1;
                camera.position.y += (camHeight - camera.position.y) * 0.1;
                
                camera.lookAt(me.x, 10, me.z);
            }

            // 2. Physique Balles
            const bulletSpeed = 8;
            for(let bid in bulletsMap) {
                const b = bulletsMap[bid];
                // Avancer mesh
                b.mesh.position.x += b.data.vx * bulletSpeed;
                b.mesh.position.z += b.data.vz * bulletSpeed;

                // Hit Detection simple (uniquement si je suis la cible)
                if (me && myId !== b.data.owner) {
                    const dist = Math.hypot(me.x - b.mesh.position.x, me.z - b.mesh.position.z);
                    if (dist < 8) {
                        // Touché !
                        me.hp -= 10;
                        updateHUD();
                        // Supprimer visuellement pour pas se faire toucher 50 fois
                        b.mesh.position.y = -100; 
                    }
                }
            }

            renderer.render(scene, camera);
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
