<!DOCTYPE html>
<html lang="fr">
<head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-29XYBNJ2CB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-29XYBNJ2CB');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WikiMind 3D Pro | AI & CAD</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg: #ffffff;
            --text: #111111;
            --sidebar: #fcfcfc;
            --border: #e5e7eb;
            --accent: #000000;
            --accent-text: #ffffff;
            --grid-line: #e5e5e5;
            --guide-color: #3b82f6;
        }

        .dark-mode {
            --bg: #0f0f0f;
            --text: #eeeeee;
            --sidebar: #161616;
            --border: #252525;
            --accent: #ffffff;
            --accent-text: #000000;
            --grid-line: #222222;
            --guide-color: #60a5fa;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
            display: flex;
            transition: background 0.3s, color 0.3s;
        }

        /* Sidebar */
        #sidebar {
            width: 320px;
            background-color: var(--sidebar);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 1.5rem;
            z-index: 30;
            box-shadow: 4px 0 20px rgba(0,0,0,0.02);
            transition: transform 0.3s ease;
            overflow-y: auto;
        }
        
        body.zen-mode #sidebar {
            transform: translateX(-100%);
            position: absolute;
        }

        /* Workspace */
        #workspace {
            flex-grow: 1;
            position: relative;
            background-color: var(--bg);
            cursor: crosshair;
            overflow: hidden;
            display: block;
        }

        #workspace.mode-3d { background-color: #e5e5e5; }
        .dark-mode #workspace.mode-3d { background-color: #111; }

        /* Split View Layout */
        #workspace.split-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
        }
        #workspace.split-view #canvas-2d {
            position: relative; width: 100%; height: 100%; border-right: 1px solid var(--border);
        }
        #workspace.split-view #container-3d {
            position: relative; width: 100%; height: 100%; opacity: 1; pointer-events: all;
        }

        /* Standard Layers */
        #canvas-2d {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            touch-action: none;
        }
        
        #container-3d {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
        }
        #container-3d.active { opacity: 1; pointer-events: all; }

        /* UI Elements */
        .btn {
            background: var(--bg); border: 1px solid var(--border); color: var(--text);
            padding: 10px 14px; border-radius: 8px; font-weight: 600; font-size: 0.75rem;
            text-transform: uppercase; letter-spacing: 0.05em; cursor: pointer;
            transition: 0.2s; display: flex; align-items: center; justify-content: flex-start; gap: 10px;
            margin-bottom: 0.5rem;
        }
        .btn:hover { background: var(--border); }
        .btn.active { background: var(--border); border-color: var(--text); }
        .btn.primary { background: var(--accent); color: var(--accent-text); border-color: var(--accent); }
        .btn.disabled { opacity: 0.4; cursor: not-allowed; pointer-events: none; }
        .btn.ai-btn { border-color: #8b5cf6; color: #8b5cf6; }
        .btn.ai-btn:hover { background: #8b5cf6; color: white; }

        /* Controls Overlay (Slider) */
        #controls-overlay {
            position: absolute; bottom: 2rem; left: 50%; transform: translateX(-50%);
            background: var(--bg); padding: 1rem 2rem; border-radius: 99px;
            border: 1px solid var(--border); box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: none; align-items: center; gap: 1.5rem; z-index: 50;
        }
        #controls-overlay.visible { display: flex; }

        input[type=range] { -webkit-appearance: none; width: 200px; height: 4px; background: var(--border); border-radius: 2px; outline: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; background: var(--accent); border-radius: 50%; cursor: pointer; transition: transform 0.1s; }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); }

        .logo-box { width: 32px; height: 32px; background: var(--accent); color: var(--accent-text); display: flex; align-items: center; justify-content: center; border-radius: 8px; font-weight: 900; }
        
        .badge { font-size: 0.6rem; padding: 2px 6px; border-radius: 4px; background: #eee; color: #555; font-weight: bold; margin-left: auto; }
        
        /* Stats & Notifications */
        #stats-area {
            position: absolute; bottom: 1.5rem; right: 1.5rem; 
            background: var(--bg); padding: 0.5rem 1rem; border-radius: 8px; 
            border: 1px solid var(--border); font-size: 0.75rem; font-weight: 600;
            z-index: 40; display: block;
        }

        #ai-loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 12px;
            z-index: 100; display: none; text-align: center;
        }

        #zen-toggle { position: absolute; top: 1rem; right: 1rem; z-index: 60; opacity: 0.5; cursor: pointer; font-size: 1.5rem; }
        #zen-toggle:hover { opacity: 1; }
    </style>
</head>
<body>

    <!-- ZEN MODE TOGGLE -->
    <div id="zen-toggle" title="Mode Zen (Masquer UI)">‚õ∂</div>

    <!-- AI LOADER -->
    <div id="ai-loader">
        <div class="mb-2 text-2xl animate-spin">‚ú®</div>
        <div class="text-xs font-bold uppercase tracking-widest">G√©n√©ration par IA...</div>
    </div>

    <!-- SIDEBAR -->
    <div id="sidebar">
        <div class="flex items-center gap-3 mb-6">
            <div class="logo-box">W</div>
            <div>
                <h1 class="font-black uppercase italic tracking-tighter text-lg leading-none">WikiMind</h1>
                <span class="text-[10px] font-bold tracking-widest text-gray-400">3D PRO CAD + AI</span>
            </div>
        </div>

        <!-- Section IA -->
        <div class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mb-1">Intelligence Artificielle</div>
        <button id="btn-ai" class="btn ai-btn w-full">
            <span>‚ú®</span> G√©n√©rer une forme
        </button>

        <div class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mt-4 mb-1">Outils Dessin</div>
        <button id="btn-ortho" class="btn w-full" title="Raccourci: O">
            <span>üìê</span> Mode Ortho (Shift)
            <span id="ortho-badge" class="badge">OFF</span>
        </button>
        <button id="btn-snap" class="btn w-full" title="Raccourci: S">
            <span>üß≤</span> Aimant Grille
            <span id="snap-badge" class="badge">OFF</span>
        </button>
        <button id="btn-undo" class="btn w-full" title="Raccourci: Ctrl+Z">
            <span>‚Ü©Ô∏è</span> Annuler
        </button>
        <button id="btn-clear" class="btn w-full text-red-500 hover:text-red-600">
            <span>üóëÔ∏è</span> Tout effacer
        </button>

        <div class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mt-4 mb-1">Affichage & Donn√©es</div>
        <button id="btn-split" class="btn w-full">
            <span>üñ•Ô∏è</span> Multi-Vues (2D/3D)
        </button>
        <button id="btn-save" class="btn w-full">
            <span>üíæ</span> Sauvegarder (JSON)
        </button>
        <button id="btn-load" class="btn w-full">
            <span>üìÇ</span> Charger (JSON)
        </button>
        <input type="file" id="file-input" style="display:none" accept=".json">

        <div class="text-[10px] font-bold text-gray-400 uppercase tracking-widest mt-4 mb-1">Production</div>
        <button id="btn-generate" class="btn primary w-full disabled">
            <span>üßä</span> G√©n√©rer 3D
        </button>
        <button id="btn-stl" class="btn w-full disabled">
            <span>üì•</span> Exporter .STL
        </button>
        <button id="btn-edit-2d" class="btn w-full hidden">
            <span>‚úèÔ∏è</span> √âditer 2D
        </button>

        <div class="mt-auto">
            <div class="p-3 bg-gray-50 dark:bg-gray-800 rounded-lg text-xs text-gray-500 mb-4 leading-relaxed border border-gray-100 dark:border-gray-700">
                <b>Astuces :</b><br>
                ‚Ä¢ <b>1√®re forme</b> : Corps principal.<br>
                ‚Ä¢ <b>Formes suivantes</b> : Trous.<br>
                ‚Ä¢ <b>Fermer</b> : Cliquer sur le point de d√©part.<br>
            </div>
            <button id="btn-theme" class="btn w-full">
                üåó Mode Sombre
            </button>
        </div>
    </div>

    <!-- WORKSPACE -->
    <div id="workspace">
        <canvas id="canvas-2d"></canvas>
        <div id="container-3d"></div>
        <div id="stats-area">Pr√™t</div>

        <!-- INFO BULLE -->
        <div id="instruction-text" class="absolute top-6 left-6 bg-white/90 dark:bg-black/90 backdrop-blur px-4 py-3 rounded-xl border border-gray-200 dark:border-gray-800 text-xs font-medium pointer-events-none select-none shadow-sm z-40">
            <div class="font-bold mb-1">Mode Esquisse</div>
            Clic gauche: Point | Clic Droit: Pan | Molette: Zoom
        </div>
    </div>

    <!-- 3D SLIDER -->
    <div id="controls-overlay">
        <span class="text-xs font-bold uppercase tracking-widest w-20">Hauteur</span>
        <input type="range" id="height-slider" min="1" max="500" value="20">
        <span id="height-val" class="font-mono text-sm font-bold w-16 text-right">20mm</span>
    </div>

    <!-- MODULE JS -->
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
        import { STLExporter } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/exporters/STLExporter.js';

        // --- CONSTANTS ---
        const GRID_SIZE = 20;
        // Cl√© API int√©gr√©e
        const API_KEY = 'faoYDKBF1ZgJ7XSSFaRRbsQYvgNB3EnK';

        // --- DOM ELEMENTS ---
        const workspace = document.getElementById('workspace');
        const canvas2D = document.getElementById('canvas-2d');
        const ctx = canvas2D.getContext('2d');
        const container3D = document.getElementById('container-3d');
        const heightSlider = document.getElementById('height-slider');
        const heightVal = document.getElementById('height-val');
        const statsArea = document.getElementById('stats-area');
        const aiLoader = document.getElementById('ai-loader');
        
        // --- STATE ---
        let shapes = [ [] ]; 
        let currentShapeIndex = 0;
        
        let is3DMode = false;
        let isOrthoMode = false;
        let isSnapMode = false;
        let isShiftDown = false;
        let isSplitView = false;
        let extrusionDepth = 20;

        // Viewport (2D)
        let scale = 1;
        let panX = 0, panY = 0;
        let isPanning = false;
        let lastMouseX, lastMouseY;

        // --- THREE.JS GLOBALS ---
        let scene, camera, renderer, controls, mesh, axesHelper;

        // --- INITIALIZATION ---
        function init() {
            panX = workspace.offsetWidth / 2;
            panY = workspace.offsetHeight / 2;

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', handleKeydown);
            window.addEventListener('keyup', handleKeyup);
            
            // Auto-load
            loadFromLocal();

            init3D();
            setupEventListeners();
            draw2D();
        }

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = (isSplitView) ? canvas2D.getBoundingClientRect() : workspace.getBoundingClientRect();
            
            canvas2D.width = rect.width * dpr;
            canvas2D.height = rect.height * dpr;
            canvas2D.style.width = '100%'; 
            canvas2D.style.height = '100%';
            
            ctx.scale(dpr, dpr);

            if(renderer && camera) {
                const w3d = container3D.offsetWidth;
                const h3d = container3D.offsetHeight;
                camera.aspect = w3d / h3d;
                camera.updateProjectionMatrix();
                renderer.setSize(w3d, h3d);
            }
            draw2D();
        }

        // --- STATE HELPERS ---
        function getCurrentPoints() { return shapes[currentShapeIndex]; }
        function isCurrentClosed() { 
            const pts = getCurrentPoints();
            return pts && pts.length > 2 && pts[0].closed;
        }

        // --- 2D DRAWING LOGIC ---

        function toWorld(sx, sy) { return { x: (sx - panX)/scale, y: (sy - panY)/scale }; }
        function toScreen(wx, wy) { return { x: wx*scale + panX, y: wy*scale + panY }; }
        function dist(p1, p2) { return Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2); }

        function handleMouseDown(e) {
            if (is3DMode && !isSplitView) return;
            if (e.target !== canvas2D) return;

            if (e.button === 1 || (e.button === 0 && e.getModifierState('Space'))) {
                isPanning = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas2D.style.cursor = 'grabbing';
                return;
            }

            if (e.button !== 0) return;

            const rect = canvas2D.getBoundingClientRect();
            const wPos = toWorld(e.clientX - rect.left, e.clientY - rect.top);
            let {x, y} = wPos;

            const pts = getCurrentPoints();

            // 1. Smart Alignment & Snap
            if (pts.length > 0 && !isCurrentClosed()) {
                const prev = pts[pts.length-1];
                const smart = getSmartPoint(prev, x, y);
                x = smart.x; y = smart.y;
            } else if (pts.length === 0 && isSnapMode) {
                x = Math.round(x/GRID_SIZE)*GRID_SIZE;
                y = Math.round(y/GRID_SIZE)*GRID_SIZE;
            }

            // 2. Closing Loop
            if (!isCurrentClosed() && pts.length > 2) {
                if (dist({x,y}, pts[0]) < 15/scale) {
                    pts[0].closed = true;
                    shapes.push([]); 
                    currentShapeIndex++;
                    saveToLocal();
                    draw2D();
                    updateUIState();
                    if(isSplitView) generate3D();
                    return;
                }
            }

            // 3. Add Point
            if (!isCurrentClosed()) {
                pts.push({x, y, r: 0});
                draw2D();
                saveToLocal();
            }
        }

        function getSmartPoint(prev, mx, my) {
            let x = mx, y = my;
            if (isSnapMode) {
                x = Math.round(x/GRID_SIZE)*GRID_SIZE;
                y = Math.round(y/GRID_SIZE)*GRID_SIZE;
            }
            const forceOrtho = isOrthoMode || isShiftDown;
            if (forceOrtho) {
                const dx = Math.abs(x - prev.x);
                const dy = Math.abs(y - prev.y);
                if (dx > dy) y = prev.y; else x = prev.x;
            } else {
                const threshold = 5 / scale;
                for(let s of shapes) {
                    for(let p of s) {
                        if(Math.abs(p.x - x) < threshold) { x = p.x; }
                        if(Math.abs(p.y - y) < threshold) { y = p.y; }
                    }
                }
            }
            return {x, y};
        }

        function handleMouseMove(e) {
            if (isPanning) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                panX += dx; panY += dy;
                lastMouseX = e.clientX; lastMouseY = e.clientY;
                draw2D();
                return;
            }

            if (is3DMode && !isSplitView) return;
            const pts = getCurrentPoints();
            if (isCurrentClosed() || pts.length === 0) return;

            const rect = canvas2D.getBoundingClientRect();
            const wPos = toWorld(e.clientX - rect.left, e.clientY - rect.top);
            draw2D(wPos);
        }

        function handleCanvasDoubleClick(e) {
            if (is3DMode && !isSplitView) return;
            const rect = canvas2D.getBoundingClientRect();
            const m = toWorld(e.clientX - rect.left, e.clientY - rect.top);
            for(let s of shapes) {
                for(let i=0; i<s.length; i++) {
                    if (dist(m, s[i]) < 10/scale) {
                        const newR = prompt(`Rayon d'arrondi (mm) pour ce coin :`, s[i].r || 0);
                        if(newR !== null && !isNaN(newR)) {
                            s[i].r = parseFloat(newR);
                            draw2D();
                            saveToLocal();
                            if(isSplitView) generate3D();
                        }
                        return;
                    }
                }
            }
        }

        // --- DRAWING RENDERER ---
        function draw2D(mousePos = null) {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas2D.width, canvas2D.height);

            const dpr = window.devicePixelRatio || 1;
            ctx.setTransform(dpr * scale, 0, 0, dpr * scale, panX * dpr, panY * dpr);

            drawGrid();

            shapes.forEach((pts, sIdx) => {
                if (pts.length === 0) return;
                const isClosed = pts.length > 2 && pts[0].closed;
                const isHole = sIdx > 0;

                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
                if (isClosed) ctx.closePath();

                ctx.strokeStyle = document.body.classList.contains('dark-mode') ? '#fff' : '#000';
                ctx.lineWidth = 2 / scale;
                if(isHole) ctx.strokeStyle = '#ef4444';
                
                if (isClosed) {
                    ctx.fillStyle = isHole ? 'rgba(239, 68, 68, 0.2)' : 'rgba(0,0,0,0.1)';
                    if(document.body.classList.contains('dark-mode') && !isHole) ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    ctx.fill();
                }
                ctx.stroke();

                pts.forEach(p => {
                    ctx.beginPath();
                    ctx.fillStyle = (p.r > 0) ? '#f59e0b' : ctx.strokeStyle;
                    if (p === pts[0] && !isClosed) ctx.fillStyle = '#22c55e';
                    ctx.arc(p.x, p.y, 4/scale, 0, Math.PI*2);
                    ctx.fill();
                });
            });

            if (mousePos && shapes[currentShapeIndex].length > 0) {
                const pts = shapes[currentShapeIndex];
                const last = pts[pts.length-1];
                const smart = getSmartPoint(last, mousePos.x, mousePos.y);

                ctx.beginPath();
                ctx.moveTo(last.x, last.y);
                ctx.lineTo(smart.x, smart.y);
                ctx.strokeStyle = '#888';
                ctx.setLineDash([5/scale, 5/scale]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                const l = Math.round(dist(last, smart));
                const sPos = toScreen((last.x+smart.x)/2, (last.y+smart.y)/2);
                ctx.setTransform(1,0,0,1,0,0);
                ctx.fillStyle = '#888';
                ctx.font = 'bold 12px Inter';
                ctx.fillText(`${l}mm`, sPos.x*dpr + 15, sPos.y*dpr - 15);
            }
        }

        function drawGrid() {
            const isDark = document.body.classList.contains('dark-mode');
            const c = isDark ? '#333' : '#e5e5e5';
            
            const tl = toWorld(0,0);
            const br = toWorld(canvas2D.width, canvas2D.height);
            
            const startX = Math.floor(tl.x/GRID_SIZE)*GRID_SIZE;
            const endX = Math.ceil(br.x/GRID_SIZE)*GRID_SIZE;
            const startY = Math.floor(tl.y/GRID_SIZE)*GRID_SIZE;
            const endY = Math.ceil(br.y/GRID_SIZE)*GRID_SIZE;

            ctx.lineWidth = 1/scale;
            ctx.strokeStyle = c;
            ctx.beginPath();
            for(let x=startX; x<=endX; x+=GRID_SIZE) { ctx.moveTo(x, startY); ctx.lineTo(x, endY); }
            for(let y=startY; y<=endY; y+=GRID_SIZE) { ctx.moveTo(startX, y); ctx.lineTo(endX, y); }
            ctx.stroke();

            ctx.lineWidth = 2/scale;
            ctx.strokeStyle = isDark ? '#666' : '#999';
            ctx.beginPath();
            ctx.moveTo(0, startY); ctx.lineTo(0, endY);
            ctx.moveTo(startX, 0); ctx.lineTo(endX, 0);
            ctx.stroke();
        }

        // --- 3D GENERATION ---

        function init3D() {
            const w = container3D.offsetWidth || 500;
            const h = container3D.offsetHeight || 500;

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, w/h, 0.1, 10000);
            camera.position.set(0, -300, 300);
            
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(w, h);
            renderer.setPixelRatio(window.devicePixelRatio);
            container3D.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(100, 100, 200);
            scene.add(dir);

            axesHelper = new THREE.AxesHelper(100);
            scene.add(axesHelper);

            const grid = new THREE.GridHelper(1000, 50, 0x888888, 0x444444);
            grid.rotation.x = Math.PI / 2;
            scene.add(grid);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function generate3D() {
            const valid = shapes.some(s => s.length > 2 && s[0].closed);
            if (!valid) return;

            if(!isSplitView) {
                is3DMode = true;
                workspace.classList.add('mode-3d');
                container3D.classList.add('active');
                canvas2D.style.opacity = '0';
            }
            createMesh();
            updateUIState();
        }

        function createMesh() {
            if (mesh) {
                scene.remove(mesh);
                if(mesh.geometry) mesh.geometry.dispose();
                if(mesh.material) mesh.material.dispose();
            }

            const mainPts = shapes[0];
            if (!mainPts || mainPts.length < 3 || !mainPts[0].closed) return;

            const createThreeShape = (pts) => {
                const s = new THREE.Shape();
                s.moveTo(pts[0].x, pts[0].y);
                for (let i = 1; i < pts.length; i++) s.lineTo(pts[i].x, pts[i].y);
                s.lineTo(pts[0].x, pts[0].y); 
                return s;
            };

            const shape = createThreeShape(mainPts);

            for (let i = 1; i < shapes.length; i++) {
                const holePts = shapes[i];
                if (holePts.length > 2 && holePts[0].closed) {
                    shape.holes.push(createThreeShape(holePts));
                }
            }

            const extrudeSettings = {
                steps: 1,
                depth: extrusionDepth,
                bevelEnabled: true,
                bevelThickness: 1,
                bevelSize: 1,
                bevelSegments: 2
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            geometry.boundingBox.getCenter(center);
            geometry.translate(-center.x, -center.y, -center.z + extrusionDepth/2);

            const isDark = document.body.classList.contains('dark-mode');
            const material = new THREE.MeshStandardMaterial({ 
                color: isDark ? 0xaaaaaa : 0xffffff,
                roughness: 0.4,
                metalness: 0.2
            });

            mesh = new THREE.Mesh(geometry, material);
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.2 }));
            mesh.add(line);

            scene.add(mesh);
        }

        // --- AI GENERATION ---
        async function generateAI() {
            const promptUser = window.prompt("D√©crivez la forme (ex: 'Une √©toile', 'Un hexagone', 'Une cl√© anglaise')");
            if (!promptUser) return;

            aiLoader.style.display = 'block';

            // SECURITY NOTE: This key is exposed in client code.
            const sysPrompt = `You are a CAD engine. User wants a 2D shape coordinate array based on: "${promptUser}". 
            Output ONLY raw JSON format: Array of objects [{x: number, y: number}]. 
            Scale fits in 200x200. Center at 0,0. Do not add markdown. Just the array.`;

            try {
                const response = await fetch('https://api.mistral.ai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${API_KEY}`
                    },
                    body: JSON.stringify({
                        model: "mistral-tiny",
                        messages: [{role: "user", content: sysPrompt}]
                    })
                });

                if(!response.ok) throw new Error("Erreur API " + response.statusText);

                const data = await response.json();
                let content = data.choices[0].message.content;
                content = content.replace(/```json/g, '').replace(/```/g, '').trim();
                
                const newPoints = JSON.parse(content);
                if (Array.isArray(newPoints) && newPoints.length > 2) {
                    newPoints[0].closed = true;
                    newPoints.forEach(p => p.r = 0);
                    applyGeneratedShape(newPoints);
                } else {
                    alert("L'IA n'a pas g√©n√©r√© une forme valide.");
                }
            } catch (e) {
                console.error(e);
                alert("Erreur de connexion √† l'IA ou format de r√©ponse invalide.");
            } finally {
                aiLoader.style.display = 'none';
            }
        }

        function applyGeneratedShape(pts) {
            shapes = [pts, []];
            currentShapeIndex = 1;
            draw2D();
            saveToLocal();
            if(isSplitView) generate3D();
        }

        // --- STORAGE & EXPORT ---
        function saveToLocal() {
            const data = { shapes, extrusionDepth };
            localStorage.setItem('wikimind_cad_project', JSON.stringify(data));
            statsArea.innerText = "Sauvegard√© auto.";
            setTimeout(() => statsArea.innerText = "Pr√™t", 2000);
        }

        function loadFromLocal() {
            const raw = localStorage.getItem('wikimind_cad_project');
            if (raw) {
                try {
                    const data = JSON.parse(raw);
                    shapes = data.shapes || [[]];
                    currentShapeIndex = Math.max(0, shapes.length - 1);
                    extrusionDepth = data.extrusionDepth || 20;
                    heightSlider.value = extrusionDepth;
                    heightVal.innerText = extrusionDepth + 'mm';
                } catch(e) { console.log("Save corrupted", e); }
            }
        }

        function downloadJSON() {
            const data = JSON.stringify({ shapes, extrusionDepth });
            const blob = new Blob([data], {type: 'application/json'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'projet_wikimind.json';
            a.click();
        }

        function uploadJSON(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const data = JSON.parse(ev.target.result);
                    shapes = data.shapes;
                    currentShapeIndex = shapes.length - 1;
                    extrusionDepth = data.extrusionDepth;
                    draw2D();
                    if(is3DMode || isSplitView) createMesh();
                } catch(err) { alert("Fichier invalide"); }
            };
            reader.readAsText(file);
        }

        // --- UI HANDLERS ---
        function handleKeydown(e) {
            if (e.key === 'Shift') { isShiftDown = true; }
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
            if (e.key.toLowerCase() === 'o') { isOrthoMode = !isOrthoMode; updateUIState(); }
            if (e.key.toLowerCase() === 's') { isSnapMode = !isSnapMode; updateUIState(); }
            if (e.key === 'Escape') { 
                if(is3DMode && !isSplitView) {
                    is3DMode = false; workspace.classList.remove('mode-3d'); container3D.classList.remove('active'); canvas2D.style.opacity='1'; updateUIState();
                }
            }
        }
        function handleKeyup(e) {
            if (e.key === 'Shift') isShiftDown = false;
        }

        function undo() {
            const pts = shapes[currentShapeIndex];
            if (pts.length > 0 && !pts[0].closed) {
                pts.pop();
            } else if (shapes.length > 1 && shapes[currentShapeIndex].length === 0) {
                shapes.pop();
                currentShapeIndex--;
                const prev = shapes[currentShapeIndex];
                if(prev && prev.length > 0) prev[0].closed = false;
            }
            draw2D();
            saveToLocal();
            if(isSplitView) generate3D();
        }

        function toggleSplitView() {
            isSplitView = !isSplitView;
            if(isSplitView) {
                workspace.classList.add('split-view');
                container3D.classList.add('active');
                canvas2D.style.opacity = '1';
                setTimeout(() => { resizeCanvas(); generate3D(); }, 100);
            } else {
                workspace.classList.remove('split-view');
                if(is3DMode) {
                    canvas2D.style.opacity = '0';
                } else {
                    container3D.classList.remove('active');
                }
                setTimeout(resizeCanvas, 100);
            }
        }

        function toggleZen() {
            document.body.classList.toggle('zen-mode');
            resizeCanvas();
        }

        function updateUIState() {
            document.getElementById('ortho-badge').innerText = isOrthoMode ? "ON" : "OFF";
            document.getElementById('ortho-badge').style.background = isOrthoMode ? "#22c55e" : "#eee";
            document.getElementById('ortho-badge').style.color = isOrthoMode ? "#fff" : "#555";
            
            document.getElementById('snap-badge').innerText = isSnapMode ? "ON" : "OFF";
            document.getElementById('snap-badge').style.background = isSnapMode ? "#22c55e" : "#eee";
            document.getElementById('snap-badge').style.color = isSnapMode ? "#fff" : "#555";

            const btnGen = document.getElementById('btn-generate');
            const btnStl = document.getElementById('btn-stl');
            const btnEdit = document.getElementById('btn-edit-2d');
            const controls = document.getElementById('controls-overlay');

            const hasClosed = shapes.some(s => s.length > 2 && s[0].closed);

            if (is3DMode && !isSplitView) {
                btnGen.classList.add('hidden');
                btnStl.classList.remove('disabled');
                btnEdit.classList.remove('hidden');
                controls.classList.add('visible');
            } else {
                btnEdit.classList.add('hidden');
                btnGen.classList.remove('hidden');
                
                if(isSplitView) {
                     controls.classList.add('visible');
                     btnStl.classList.remove('disabled');
                } else {
                     controls.classList.remove('visible');
                     btnStl.classList.add('disabled');
                }

                if (hasClosed) {
                    btnGen.classList.remove('disabled');
                } else {
                    btnGen.classList.add('disabled');
                }
            }
        }

        function setupEventListeners() {
            canvas2D.addEventListener('mousedown', handleMouseDown);
            canvas2D.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', () => { isPanning = false; canvas2D.style.cursor = 'crosshair'; });
            canvas2D.addEventListener('wheel', (e) => {
                e.preventDefault();
                scale *= e.deltaY < 0 ? 1.1 : 0.9;
                draw2D();
            }, {passive:false});
            canvas2D.addEventListener('dblclick', handleCanvasDoubleClick);

            document.getElementById('btn-ortho').onclick = () => { isOrthoMode = !isOrthoMode; updateUIState(); };
            document.getElementById('btn-snap').onclick = () => { isSnapMode = !isSnapMode; updateUIState(); };
            document.getElementById('btn-undo').onclick = undo;
            document.getElementById('btn-clear').onclick = () => { 
                if(confirm('Effacer tout ?')) { 
                    shapes = [[]]; currentShapeIndex=0; draw2D(); saveToLocal(); 
                    if(mesh) { scene.remove(mesh); mesh=null; }
                } 
            };
            document.getElementById('btn-generate').onclick = generate3D;
            document.getElementById('btn-edit-2d').onclick = () => { is3DMode = false; workspace.classList.remove('mode-3d'); container3D.classList.remove('active'); canvas2D.style.opacity='1'; updateUIState(); };
            
            document.getElementById('btn-stl').onclick = () => { 
                if(!mesh) return;
                const exporter = new STLExporter();
                const res = exporter.parse(mesh);
                const b = new Blob([res],{type:'text/plain'});
                const l = document.createElement('a'); l.href = URL.createObjectURL(b); l.download = 'modele_3d.stl'; l.click();
            };
            
            document.getElementById('btn-theme').onclick = () => { document.body.classList.toggle('dark-mode'); draw2D(); if(mesh) createMesh(); };
            document.getElementById('btn-ai').onclick = generateAI;
            document.getElementById('btn-save').onclick = downloadJSON;
            document.getElementById('btn-load').onclick = () => document.getElementById('file-input').click();
            document.getElementById('file-input').onchange = uploadJSON;
            document.getElementById('btn-split').onclick = toggleSplitView;
            document.getElementById('zen-toggle').onclick = toggleZen;

            heightSlider.oninput = () => { 
                extrusionDepth = parseInt(heightSlider.value); 
                heightVal.innerText = extrusionDepth + 'mm'; 
                saveToLocal();
                if(is3DMode || isSplitView) createMesh(); 
            };

            updateUIState();
        }

        init();
    </script>
</body>

</html>
