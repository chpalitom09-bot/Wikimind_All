<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WikiMind Dictate - Saisie & Correction Live</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        :root { --bg: #111; --text: #eee; --accent: #2dd4bf; }
        body { background: var(--bg); color: var(--text); font-family: 'Inter', sans-serif; overflow-x: hidden; }
        
        .glass {
            background: rgba(30, 30, 30, 0.6); backdrop-filter: blur(12px);
            border: 1px solid rgba(255,255,255,0.1); border-radius: 20px;
        }

        .mic-btn {
            width: 70px; height: 70px; border-radius: 50%;
            background: #333; display: flex; align-items: center; justify-content: center;
            font-size: 28px; cursor: pointer; transition: 0.3s;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5); border: 2px solid #444;
        }
        .mic-btn.active {
            background: #ef4444; color: white; border-color: #ef4444;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 70% { box-shadow: 0 0 0 20px rgba(239, 68, 68, 0); } 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } }

        .editor {
            width: 100%; min-height: 40vh; background: transparent; border: none;
            outline: none; font-size: 1.2rem; line-height: 1.6; color: #ddd;
            resize: none;
        }
        
        /* Switch Correction Live */
        .toggle-checkbox:checked { right: 0; border-color: #2dd4bf; }
        .toggle-checkbox:checked + .toggle-label { background-color: #2dd4bf; }
    </style>
</head>
<body class="flex flex-col min-h-screen">

    <!-- Header -->
    <header class="p-6 flex justify-between items-center border-b border-gray-800 bg-black/50 backdrop-blur-md fixed w-full z-50">
        <div class="font-black text-xl italic tracking-tighter">WikiMind <span class="text-teal-400">Dictate</span></div>
        
        <!-- Toggle Correction Live -->
        <div class="flex items-center gap-3">
            <span class="text-xs font-bold uppercase text-gray-400">Correction Auto</span>
            <div class="relative inline-block w-12 mr-2 align-middle select-none transition duration-200 ease-in">
                <input type="checkbox" name="toggle" id="auto-fix-toggle" class="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer border-gray-800 left-0 transition-all duration-300"/>
                <label for="auto-fix-toggle" class="toggle-label block overflow-hidden h-6 rounded-full bg-gray-800 cursor-pointer"></label>
            </div>
        </div>
    </header>

    <!-- Main -->
    <main class="flex-grow pt-32 pb-40 px-4 max-w-4xl mx-auto w-full flex flex-col gap-6">
        
        <!-- Status Bar -->
        <div id="status-msg" class="text-center text-sm font-bold text-gray-500 uppercase tracking-widest">
            Pr√™t √† dicter
        </div>

        <!-- Editor -->
        <div class="glass p-8 relative min-h-[50vh] flex flex-col">
            <textarea id="editor" class="editor" placeholder="Appuie sur le micro et parle..."></textarea>
            <!-- Texte fant√¥me (ce que l'IA entend avant de valider) -->
            <div id="ghost-text" class="absolute bottom-4 left-8 right-8 text-gray-500 italic opacity-50 pointer-events-none text-lg"></div>
        </div>

        <!-- Actions Manuelles -->
        <div class="grid grid-cols-2 gap-4">
            <button onclick="manualCorrect()" class="glass p-4 text-center hover:bg-teal-900/30 transition text-teal-400 font-bold border-teal-900">
                ‚ú® Correction Totale
            </button>
            <button onclick="formatCourse()" class="glass p-4 text-center hover:bg-blue-900/30 transition text-blue-400 font-bold border-blue-900">
                üéì Structurer en Cours
            </button>
        </div>
    </main>

    <!-- Controls -->
    <div class="fixed bottom-10 left-0 w-full flex justify-center z-50">
        <div class="glass px-8 py-4 flex items-center gap-6 shadow-2xl bg-black">
            <button id="mic-btn" onclick="toggleMic()" class="mic-btn">üéôÔ∏è</button>
            <div class="flex flex-col">
                <span id="mic-label" class="font-bold text-white">Micro OFF</span>
                <span class="text-xs text-gray-400">Cliquez pour parler</span>
            </div>
        </div>
    </div>

    <script>
        // --- API KEY ---
        const MISTRAL_API_KEY = "RmL56FeSccbbNpOC1KIDrYozHSFmY5eD";

        // --- ELEMENTS ---
        const editor = document.getElementById('editor');
        const ghost = document.getElementById('ghost-text');
        const micBtn = document.getElementById('mic-btn');
        const statusMsg = document.getElementById('status-msg');
        const autoFixToggle = document.getElementById('auto-fix-toggle');

        // --- SPEECH RECOGNITION CONFIG ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        let isListening = false;
        let silenceTimer;

        if (!SpeechRecognition) {
            alert("‚ö†Ô∏è Ton navigateur ne supporte pas la saisie vocale. Utilise Chrome ou Edge.");
            statusMsg.innerText = "Navigateur non compatible";
        } else {
            recognition = new SpeechRecognition();
            recognition.continuous = true;      // Ne s'arr√™te pas
            recognition.interimResults = true;  // Affiche le texte en direct
            recognition.lang = 'fr-FR';

            recognition.onstart = () => {
                isListening = true;
                micBtn.classList.add('active');
                document.getElementById('mic-label').innerText = "√âcoute en cours...";
                statusMsg.innerText = "üî¥ Enregistrement...";
                statusMsg.className = "text-center text-sm font-bold text-red-500 uppercase tracking-widest animate-pulse";
            };

            recognition.onend = () => {
                // Red√©marrage automatique si on ne l'a pas arr√™t√© manuellement
                if (isListening) {
                    try { recognition.start(); } catch(e) {}
                } else {
                    micBtn.classList.remove('active');
                    document.getElementById('mic-label').innerText = "Micro OFF";
                    statusMsg.innerText = "‚è∏Ô∏è Pause";
                    statusMsg.className = "text-center text-sm font-bold text-gray-500 uppercase tracking-widest";
                }
            };

            recognition.onerror = (event) => {
                console.error("Erreur Saisie Vocale:", event.error);
                if(event.error === 'not-allowed') {
                    alert("üö´ Acc√®s Micro refus√© ! V√©rifie que tu es en HTTPS ou Localhost et autorise le micro.");
                    isListening = false;
                }
                if(event.error === 'network') {
                    statusMsg.innerText = "‚ö†Ô∏è Probl√®me r√©seau";
                }
            };

            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscriptChunk = '';

                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscriptChunk += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }

                // Affichage du texte provisoire (gris)
                ghost.innerText = interimTranscript;

                // Ajout du texte finalis√© dans l'√©diteur
                if (finalTranscriptChunk) {
                    const textToAdd = finalTranscriptChunk.trim();
                    if (textToAdd) {
                        // Ajout propre avec espace
                        const currentText = editor.value;
                        const prefix = (currentText.length > 0 && !currentText.endsWith('\n') && !currentText.endsWith(' ')) ? ' ' : '';
                        
                        // Si "Auto Fix" est activ√©, on corrige ce petit bout imm√©diatement
                        if(autoFixToggle.checked) {
                            quickCorrectChunk(textToAdd, prefix);
                        } else {
                            editor.value += prefix + textToAdd;
                        }
                        
                        editor.scrollTop = editor.scrollHeight;
                    }
                }
            };
        }

        // --- FONCTIONS ---

        function toggleMic() {
            if (!recognition) return;
            if (isListening) {
                isListening = false;
                recognition.stop();
            } else {
                // Test pour voir si HTTPS/Localhost
                if (window.location.protocol === 'file:') {
                    alert("‚ö†Ô∏è ATTENTION : La saisie vocale ne marche pas en ouvrant le fichier directement.\n\nIl faut utiliser un serveur local (ex: Live Server sur VSCode).");
                }
                try {
                    recognition.start();
                } catch(e) { console.log("D√©j√† d√©marr√©"); }
            }
        }

        // --- CORRECTION IA EN ARRI√àRE PLAN (Chunk par Chunk) ---
        async function quickCorrectChunk(text, prefix) {
            // On affiche le texte brut d'abord pour la r√©activit√©
            const startPos = editor.value.length;
            editor.value += prefix + text; 
            
            // Indicateur visuel discret
            statusMsg.innerText = "ü§ñ Correction IA en cours...";
            
            try {
                const response = await fetch("https://api.mistral.ai/v1/chat/completions", {
                    method: "POST",
                    headers: { "Content-Type": "application/json", "Authorization": `Bearer ${MISTRAL_API_KEY}` },
                    body: JSON.stringify({
                        model: "mistral-small-latest",
                        messages: [
                            { role: "system", content: "Corrige uniquement l'orthographe et la grammaire de ce segment de phrase. Garde le sens exact. Renvoie juste le texte corrig√©." },
                            { role: "user", content: text }
                        ],
                        temperature: 0.1
                    })
                });

                const data = await response.json();
                if(data.choices) {
                    const corrected = data.choices[0].message.content.trim();
                    // Remplacement "magique" du texte brut par le texte corrig√©
                    const originalFull = editor.value;
                    // On remplace la fin de la chaine (le dernier ajout)
                    // Note: C'est une simplification, si l'utilisateur tape entre temps √ßa peut sauter, mais pour de la dict√©e √ßa passe.
                    editor.value = originalFull.substring(0, startPos) + prefix + corrected;
                }
            } catch (e) {
                console.error("Erreur IA", e);
            }
            statusMsg.innerText = "üî¥ Enregistrement...";
        }

        // --- CORRECTION TOTALE MANUELLE ---
        async function manualCorrect() {
            const text = editor.value;
            if(!text) return;
            statusMsg.innerText = "‚ú® Correction globale...";
            
            const corrected = await callAI("Corrige parfaitement ce texte (grammaire, syntaxe, ponctuation).", text);
            if(corrected) editor.value = corrected;
            
            statusMsg.innerText = "Pr√™t";
        }

        // --- FORMATAGE COURS ---
        async function formatCourse() {
            const text = editor.value;
            if(!text) return;
            statusMsg.innerText = "üéì Structuration du cours...";
            
            const course = await callAI("Transforme ce texte en cours structur√© (Markdown). Utilise des Titres, Listes √† puces, et mets les mots cl√©s en Gras.", text);
            if(course) editor.value = course; // L'√©diteur supporte le texte brut, tu verras le markdown
            
            statusMsg.innerText = "Pr√™t";
        }

        // --- APPEL API G√âN√âRIQUE ---
        async function callAI(systemPrompt, userText) {
            try {
                const response = await fetch("https://api.mistral.ai/v1/chat/completions", {
                    method: "POST",
                    headers: { "Content-Type": "application/json", "Authorization": `Bearer ${MISTRAL_API_KEY}` },
                    body: JSON.stringify({
                        model: "mistral-small-latest",
                        messages: [{ role: "system", content: systemPrompt }, { role: "user", content: userText }]
                    })
                });
                const data = await response.json();
                return data.choices[0].message.content;
            } catch (e) {
                alert("Erreur IA : " + e);
                return null;
            }
        }
    </script>
</body>
</html>
